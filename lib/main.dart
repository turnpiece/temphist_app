import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:geocoding/geocoding.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // This is auto-generated by FlutterFire CLI
import 'package:firebase_auth/firebase_auth.dart';

import 'package:flutter/services.dart';
import 'dart:io' show Platform;
import 'dart:async'; // Added for StreamSubscription and StreamController

import 'services/temperature_service.dart';
import 'config/app_config.dart';
import 'utils/debug_utils.dart';

// App color constants
// Note: These are no longer const because they depend on runtime configuration
// but they maintain the same interface for backward compatibility
bool get DEBUGGING => AppConfig.isDebugMode;
bool get SIMULATE_ENDPOINT_FAILURES => AppConfig.enableEndpointFailureSimulation;
const kBackgroundColour = Color(0xFF242456);
const kAccentColour = Color(0xFFFF6B6B);
const kTextPrimaryColour = Color(0xFFECECEC);
const kSummaryColour = Color(0xFF51CF66);
const kAverageColour = Color(0xFF4DABF7);
const kTrendColour = Color(0xFFAAAA00);
const kTrendLineColour = kTrendColour;
const kBarOtherYearColour = kAccentColour;
const kBarCurrentYearColour = kSummaryColour;
const kAxisLabelColour = Color(0xFFECECEC);
const kAxisGridColour = kAxisLabelColour;
const kGreyLabelColour = Color(0xFFB0B0B0);

// Layout constants for easy adjustment
const double kScreenPadding = 8.0;
const double kTitleRowHorizontalMargin = 4.0;
const double kTitleRowIconRightPadding = 6.0;
const double kSectionHorizontalMargin = 4.0;
const double kCitySummaryHorizontalMargin = 4.0;
const double kChartHorizontalMargin = 4.0;
const double kChartInnerPadding = 4.0;
const double kSectionBottomPadding = 22.0;
const double kSectionTopPadding = 22.0;
const double kContentVerticalPadding = 32.0; // Vertical padding for main content area

// Font size constants
const double kFontSizeTitle = 20.0;
const double kFontSizeBody = 14.0;
const double kFontSizeAxisLabel = 12.0;

// Time constants
const int kUseYesterdayHourThreshold = 3; // Use yesterday's data if current hour is before this

/// Clean up and validate location strings for better API compatibility
String _cleanupLocationString(String location) {
  if (location.isEmpty) return 'London, UK';
  
  // Remove extra whitespace and normalize commas
  String cleaned = location.trim();
  
  // Replace multiple spaces with single space
  cleaned = cleaned.replaceAll(RegExp(r'\s+'), ' ');
  
  // Normalize comma spacing (ensure space after comma)
  cleaned = cleaned.replaceAll(RegExp(r',\s*'), ', ');
  
  // Remove trailing comma if present
  cleaned = cleaned.replaceAll(RegExp(r',\s*$'), '');
  
  // Ensure we have at least a city and country
  if (!cleaned.contains(',')) {
    // If no comma, assume it's just a city, add default country
    cleaned = '$cleaned, UK';
  }
  
  return cleaned;
}

/// Detect suspicious or obviously incorrect location strings
bool _isLocationSuspicious(String location) {
  if (location.isEmpty) return true;
  
  final lowerLocation = location.toLowerCase();
  
  // Check for street addresses (which are usually wrong for city-level queries)
  if (lowerLocation.contains('street') || 
      lowerLocation.contains('st,') ||
      lowerLocation.contains('ave,') ||
      lowerLocation.contains('road') ||
      lowerLocation.contains('rd,') ||
      lowerLocation.contains('drive') ||
      lowerLocation.contains('dr,') ||
      lowerLocation.contains('lane') ||
      lowerLocation.contains('ln,') ||
      lowerLocation.contains('blvd') ||
      lowerLocation.contains('boulevard')) {
    return true;
  }
  
  // Check for postal codes (which are usually wrong for city-level queries)
  if (RegExp(r'\d{5}').hasMatch(location) || // US ZIP codes
      RegExp(r'[A-Z]\d[A-Z]\s?\d[A-Z]\d').hasMatch(location)) { // Canadian postal codes
    return true;
  }
  
  // Check for coordinates (which are obviously wrong)
  if (lowerLocation.contains('°') || 
      lowerLocation.contains('north') ||
      lowerLocation.contains('south') ||
      lowerLocation.contains('east') ||
      lowerLocation.contains('west')) {
    return true;
  }
  
  // Check for very short or very long location strings
  if (location.length < 3 || location.length > 100) {
    return true;
  }
  
  return false;
}

// Legacy function for backward compatibility - use DebugUtils.log() instead
void debugPrintIfDebugging(Object? message) {
  DebugUtils.log(message.toString());
}



void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Configure system UI overlay to extend app background over status bar and navigation bar
  _setSystemUIOverlayStyle();
  
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  // Ensure user is signed in (anonymous)
  await _ensureSignedIn();
  runApp(TempHist());
}

void _setSystemUIOverlayStyle() {
  if (Platform.isIOS) {
    // iOS-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarBrightness: Brightness.dark, // Light text on dark background
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else if (Platform.isAndroid) {
    // Android-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light, // Light icons/text
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else {
    // For other platforms, use a default configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
      ),
    );
  }
}

Future<void> _ensureSignedIn() async {
  final auth = FirebaseAuth.instance;
  if (auth.currentUser == null) {
    await auth.signInAnonymously();
  }
}

class TempHist extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'TempHist',
      home: TemperatureScreen(),
    );
  }
}

class TemperatureScreen extends StatefulWidget {
  final Future<Map<String, dynamic>?>? testFuture;
  final AsyncSnapshot<Map<String, dynamic>?>? testSnapshot;

  TemperatureScreen({this.testFuture, this.testSnapshot});

  @override
  _TemperatureScreenState createState() => _TemperatureScreenState();
}

class _TemperatureScreenState extends State<TemperatureScreen> with WidgetsBindingObserver {
  Future<Map<String, dynamic>?>? futureChartData;
  bool _isShowingCachedData = false;
  Timer? _dateCheckTimer;
  DateTime? _lastCheckedDate;
  Timer? _loadingMessageTimer;
  int _loadingElapsedSeconds = 0;
  String _currentLoadingMessage = '';
  String _determinedLocation = ''; // Full location for API
  String _displayLocation = ''; // Short location for display
  bool _isLocationDetermined = false;
  DateTime? _locationDeterminedAt; // Timestamp when location was last determined
  bool _isDataLoading = false;
  
  // Chart series controller for progressive loading
  ChartSeriesController? _chartSeriesController;
  
  // Add error tracking for different data types
  bool _averageDataFailed = false;
  bool _trendDataFailed = false;
  bool _summaryDataFailed = false;
  bool _chartDataHasGaps = false;
  
  // Rate limit tracking
  bool _averageDataRateLimited = false;
  bool _trendDataRateLimited = false;
  bool _summaryDataRateLimited = false;
  bool _chartDataRateLimited = false; // Track if chart data fetching is rate limited
  
  // Add automatic retry timer
  Timer? _autoRetryTimer;
  
  // Store current data for updates
  Map<String, dynamic>? _currentData;
  
  // Track retry loading states
  bool _isRetryingAverage = false;
  bool _isRetryingTrend = false;
  bool _isRetryingSummary = false;
  
  // Simulation state for testing
  bool _simulateAverageFailure = AppConfig.defaultSimulateAverageFailure;
  bool _simulateTrendFailure = AppConfig.defaultSimulateTrendFailure;
  bool _simulateSummaryFailure = AppConfig.defaultSimulateSummaryFailure;

  geo.Position? _lastPosition;
  StreamSubscription<geo.Position>? _positionStreamSubscription;

  // Track chart data retry attempts
  bool _isRetryingChartData = false;
  int _chartDataRetryCount = 0;
  static const int _maxChartDataRetries = 3;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _startListeningToLocationChanges();
    // Initialize with location determination first, then load data
    _initializeApp();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _positionStreamSubscription?.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    
    if (state == AppLifecycleState.resumed) {
      debugPrintIfDebugging('App resumed - checking if location needs refresh');
      _checkAndRefreshLocationIfNeeded();
    }
  }

  Future<void> _initializeApp() async {
    // If we have a test future, use it directly
    if (widget.testFuture != null) {
      futureChartData = widget.testFuture;
      return;
    }
    
    // Clear cache to ensure progressive loading is visible
    await _clearCache();
    
    // First determine location
    await _determineLocation();
    
    // Then start loading temperature data progressively
    _isShowingCachedData = false;
    _isDataLoading = true;
    
    // Start the loading message timer after location is determined
    _startLoadingMessageTimer();
    
    // Start progressive loading in the background
    _loadChartDataProgressive();
  }

  Future<void> _checkAndRefreshLocationIfNeeded() async {
    // If no location has been determined yet, don't refresh
    if (!_isLocationDetermined || _locationDeterminedAt == null) {
      return;
    }
    
    final now = DateTime.now();
    final timeSinceLastLocation = now.difference(_locationDeterminedAt!);
    
    // Refresh location if it's been more than 1 hour
    if (timeSinceLastLocation.inHours >= 1) {
      debugPrintIfDebugging('Location is ${timeSinceLastLocation.inHours} hours old, refreshing...');
      await _refreshLocationAndData();
    } else {
      debugPrintIfDebugging('Location is only ${timeSinceLastLocation.inMinutes} minutes old, keeping cached location');
    }
  }

  Future<void> _refreshLocationAndData() async {
    debugPrintIfDebugging('Refreshing location and data...');
    
    // Reset location state
    setState(() {
      _isLocationDetermined = false;
      _determinedLocation = '';
      _displayLocation = '';
      _locationDeterminedAt = null;
    });
    
    // Determine new location
    await _determineLocation();
    
    // Reload data with new location using progressive loading
    _isShowingCachedData = false;
    _isDataLoading = true;
    
    // Start progressive loading in the background
    _loadChartDataProgressive();
    
    // Restart loading message timer
    _startLoadingMessageTimer();
  }

  void _startAutoRetryTimer() {
    // Cancel any existing timer
    _autoRetryTimer?.cancel();
    
    // Start a new timer that will retry after 10 seconds
    // But only retry endpoints that aren't rate limited
    _autoRetryTimer = Timer(const Duration(seconds: 10), () {
      if (mounted) {
        final shouldRetryAverage = _averageDataFailed && !_averageDataRateLimited;
        final shouldRetryTrend = _trendDataFailed && !_trendDataRateLimited;
        final shouldRetrySummary = _summaryDataFailed && !_summaryDataRateLimited;
        
        if (shouldRetryAverage || shouldRetryTrend || shouldRetrySummary) {
          _retryFailedData();
        }
      }
    });
  }

  void _stopAutoRetryTimer() {
    _autoRetryTimer?.cancel();
    _autoRetryTimer = null;
  }

  void _loadInitialData() async {
    debugPrintIfDebugging('_loadInitialData: Starting data load');
    
    // Stop any existing auto-retry timer
    _stopAutoRetryTimer();
    
    // Reset error states
    _resetErrorStates();
    
    // Use test data if provided
    if (widget.testFuture != null) {
      debugPrintIfDebugging('_loadInitialData: Using test data');
      setState(() {
        futureChartData = widget.testFuture!;
      });
      return;
    }
    
    // First determine location
    await _determineLocation();
    
    // Then start loading temperature data using progressive loading
    _isShowingCachedData = false;
    _isDataLoading = true;
    
    // Start progressive loading in the background
    _loadChartDataProgressive();
    
    // Start the loading message timer after location is determined
    _startLoadingMessageTimer();
  }

  void _resetErrorStates() {
    setState(() {
      _averageDataFailed = false;
      _trendDataFailed = false;
      _summaryDataFailed = false;
      _chartDataHasGaps = false;
      _isRetryingAverage = false;
      _isRetryingTrend = false;
      _isRetryingSummary = false;
      _isRetryingChartData = false;
      _chartDataRetryCount = 0;
      
      // Reset rate limit flags
      _averageDataRateLimited = false;
      _trendDataRateLimited = false;
      _summaryDataRateLimited = false;
      _chartDataRateLimited = false;
    });
  }

  Future<void> _clearCache() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('cachedChartData');
      debugPrintIfDebugging('Cache cleared for simulation mode');
    } catch (e) {
      debugPrintIfDebugging('Error clearing cache: $e');
    }
  }

  Future<void> _retryFailedData() async {
    if (!_averageDataFailed && !_trendDataFailed && !_summaryDataFailed) {
      return; // Nothing to retry
    }
    
    debugPrintIfDebugging('Retrying failed data fetches...');
    
    try {
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final mmdd = DateFormat('MM-dd').format(dateToUse);
      final city = _determinedLocation.isNotEmpty ? _determinedLocation : 'London, UK';
      
      final service = TemperatureService();
      
      // Retry average data if it failed
      if (_averageDataFailed) {
        setState(() {
          _isRetryingAverage = true;
        });
        
        try {
          final averageData = await _simulateEndpointFailure('average', () => 
            service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: 30))
          );
          final newAverage = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
          
          if (newAverage != null) {
            setState(() {
              _averageDataFailed = false;
              _isRetryingAverage = false;
            });
            // Update the current data with new average
            if (futureChartData != null) {
              // We need to rebuild the data with the new average
              _rebuildDataWithNewAverage(newAverage);
            }
            // Stop auto-retry timer if no more failures
            if (!_trendDataFailed && !_summaryDataFailed) {
              _stopAutoRetryTimer();
            }
          } else {
            setState(() {
              _isRetryingAverage = false;
            });
          }
        } catch (e) {
          debugPrintIfDebugging('Retry of average data failed: $e');
          
          // Check if it's a rate limit error - don't retry these
          if (e is RateLimitException) {
            setState(() {
              _isRetryingAverage = false;
              _averageDataFailed = true;
              _averageDataRateLimited = true; // New flag for rate limiting
            });
            // Stop auto-retry timer for rate limit errors
            _stopAutoRetryTimer();
          } else {
            setState(() {
              _isRetryingAverage = false;
            });
          }
        }
      }
      
      // Retry trend data if it failed
      if (_trendDataFailed) {
        setState(() {
          _isRetryingTrend = true;
        });
        
        try {
          final trendData = await _simulateEndpointFailure('trend', () => 
            service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: 30))
          );
          final newSlope = trendData['slope'];
          if (newSlope != null) {
            setState(() {
              _trendDataFailed = false;
              _isRetryingTrend = false;
            });
            // Update the current data with new trend
            if (futureChartData != null) {
              _rebuildDataWithNewTrend((newSlope as num).toDouble());
            }
            // Stop auto-retry timer if no more failures
            if (!_averageDataFailed && !_summaryDataFailed) {
              _stopAutoRetryTimer();
            }
          } else {
            setState(() {
              _isRetryingTrend = false;
            });
          }
        } catch (e) {
          debugPrintIfDebugging('Retry of trend data failed: $e');
          setState(() {
            _isRetryingTrend = false;
          });
        }
      }
      
      // Retry summary data if it failed
      if (_summaryDataFailed) {
        setState(() {
          _isRetryingSummary = true;
        });
        
        try {
          final summaryData = await service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: 30));
          final newSummary = summaryData['summary']?.toString();
          if (newSummary != null && newSummary.isNotEmpty) {
            setState(() {
              _summaryDataFailed = false;
              _isRetryingSummary = false;
            });
            // Update the current data with new summary
            if (futureChartData != null) {
              _rebuildDataWithNewSummary(newSummary);
            }
            // Stop auto-retry timer if no more failures
            if (!_averageDataFailed && !_trendDataFailed) {
              _stopAutoRetryTimer();
            }
          } else {
            setState(() {
              _isRetryingSummary = false;
            });
          }
        } catch (e) {
          debugPrintIfDebugging('Retry of summary data failed: $e');
          setState(() {
            _isRetryingSummary = false;
          });
        }
      }
    } catch (e) {
      debugPrintIfDebugging('Error during retry: $e');
    }
  }

  Future<void> _retryAverageData() async {
    if (!_averageDataFailed) return;
    
    debugPrintIfDebugging('Retrying average data...');
    
    try {
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final mmdd = DateFormat('MM-dd').format(dateToUse);
      final city = _determinedLocation.isNotEmpty ? _determinedLocation : 'London, UK';
      
      final service = TemperatureService();
      
      setState(() {
        _isRetryingAverage = true;
      });
      
      try {
        final averageData = await _simulateEndpointFailure('average', () => 
          service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: 30))
        );
        final newAverage = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
        
        if (newAverage != null) {
          setState(() {
            _averageDataFailed = false;
            _isRetryingAverage = false;
          });
          _rebuildDataWithNewAverage(newAverage);
          // Stop auto-retry timer if no more failures
          if (!_trendDataFailed && !_summaryDataFailed) {
            _stopAutoRetryTimer();
          }
        } else {
          setState(() {
            _isRetryingAverage = false;
          });
        }
      } catch (e) {
        debugPrintIfDebugging('Retry of average data failed: $e');
        setState(() {
          _isRetryingAverage = false;
        });
      }
    } catch (e) {
      debugPrintIfDebugging('Error during average retry: $e');
      setState(() {
        _isRetryingAverage = false;
      });
    }
  }

  Future<void> _retryTrendData() async {
    if (!_trendDataFailed) return;
    
    debugPrintIfDebugging('Retrying trend data...');
    
    try {
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final mmdd = DateFormat('MM-dd').format(dateToUse);
      final city = _determinedLocation.isNotEmpty ? _determinedLocation : 'London, UK';
      
      final service = TemperatureService();
      
      setState(() {
        _isRetryingTrend = true;
      });
      
      try {
        final trendData = await service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: 30));
        final newSlope = trendData['slope'];
        if (newSlope != null) {
          setState(() {
            _trendDataFailed = false;
            _isRetryingTrend = false;
          });
          _rebuildDataWithNewTrend((newSlope as num).toDouble());
          // Stop auto-retry timer if no more failures
          if (!_averageDataFailed && !_summaryDataFailed) {
            _stopAutoRetryTimer();
          }
        } else {
          setState(() {
            _isRetryingTrend = false;
          });
        }
      } catch (e) {
        debugPrintIfDebugging('Retry of trend data failed: $e');
        setState(() {
          _isRetryingTrend = false;
        });
      }
    } catch (e) {
      debugPrintIfDebugging('Error during trend retry: $e');
      setState(() {
        _isRetryingTrend = false;
      });
    }
  }

  Future<void> _retrySummaryData() async {
    if (!_summaryDataFailed) return;
    
    debugPrintIfDebugging('Retrying summary data...');
    
    try {
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final mmdd = DateFormat('MM-dd').format(dateToUse);
      final city = _determinedLocation.isNotEmpty ? _determinedLocation : 'London, UK';
      
      final service = TemperatureService();
      
      setState(() {
        _isRetryingSummary = true;
      });
      
      try {
        final summaryData = await service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: 30));
        final newSummary = summaryData['summary']?.toString();
        if (newSummary != null && newSummary.isNotEmpty) {
          setState(() {
            _summaryDataFailed = false;
            _isRetryingSummary = false;
          });
          _rebuildDataWithNewSummary(newSummary);
          // Stop auto-retry timer if no more failures
          if (!_averageDataFailed && !_trendDataFailed) {
            _stopAutoRetryTimer();
          }
        } else {
          setState(() {
            _isRetryingSummary = false;
          });
        }
      } catch (e) {
        debugPrintIfDebugging('Retry of summary data failed: $e');
        setState(() {
          _isRetryingSummary = false;
        });
      }
    } catch (e) {
      debugPrintIfDebugging('Error during summary retry: $e');
      setState(() {
        _isRetryingSummary = false;
      });
    }
  }

  Future<void> _retryChartData() async {
    if (_chartDataRetryCount >= _maxChartDataRetries) {
      debugPrintIfDebugging('Max chart data retries reached, not retrying further');
      return;
    }
    
    debugPrintIfDebugging('Retrying chart data... (attempt ${_chartDataRetryCount + 1})');
    
    setState(() {
      _isRetryingChartData = true;
    });
    
    try {
      // Increment retry count
      _chartDataRetryCount++;
      
      // Trigger a refresh to reload chart data
      await _handleRefresh();
      
      setState(() {
        _isRetryingChartData = false;
      });
    } catch (e) {
      debugPrintIfDebugging('Error during chart data retry: $e');
      setState(() {
        _isRetryingChartData = false;
      });
    }
  }

  void _rebuildDataWithNewAverage(double newAverage) {
    if (_currentData != null) {
      setState(() {
        _currentData!['averageTemperature'] = newAverage;
      });
    }
  }

  void _rebuildDataWithNewTrend(double newSlope) {
    if (_currentData != null) {
      setState(() {
        _currentData!['trendSlope'] = newSlope;
      });
    }
  }

  void _rebuildDataWithNewSummary(String newSummary) {
    if (_currentData != null) {
      setState(() {
        _currentData!['summary'] = newSummary;
      });
    }
  }

  Future<void> _determineLocation() async {
    try {
      String city = 'London, UK';
      
      // Try to get user's city via geolocation
      try {
        debugPrintIfDebugging('_determineLocation: Starting geolocation');
        
        bool serviceEnabled = await geo.Geolocator.isLocationServiceEnabled();
        if (serviceEnabled) {
          geo.LocationPermission permission = await geo.Geolocator.checkPermission();
          if (permission == geo.LocationPermission.denied) {
            permission = await geo.Geolocator.requestPermission();
          }
          if (permission == geo.LocationPermission.whileInUse || permission == geo.LocationPermission.always) {
            try {
              geo.Position position = await geo.Geolocator.getCurrentPosition(
                desiredAccuracy: geo.LocationAccuracy.low,
              ).timeout(const Duration(seconds: 10));
              
              debugPrintIfDebugging('_determineLocation: Position obtained - lat: ${position.latitude}, lon: ${position.longitude}');
              
              List<Placemark> placemarks = await placemarkFromCoordinates(
                position.latitude, 
                position.longitude
              ).timeout(const Duration(seconds: 10));
              
              if (placemarks.isNotEmpty) {
                final placemark = placemarks.first;
                if (placemark.locality != null && placemark.locality!.isNotEmpty) {
                  final locality = placemark.locality!;
                  final country = placemark.country;
                  final administrativeArea = placemark.administrativeArea;
                  
                  // Build a more specific location string to avoid ambiguity
                  if (country != null && country.isNotEmpty) {
                    if (administrativeArea != null && administrativeArea.isNotEmpty) {
                      city = '$locality, $administrativeArea, $country';
                    } else {
                      city = '$locality, $country';
                    }
                  } else if (administrativeArea != null && administrativeArea.isNotEmpty) {
                    city = '$locality, $administrativeArea';
                  } else {
                    city = locality;
                  }
                  
                  debugPrintIfDebugging('Geolocation result - Locality: $locality, Admin: $administrativeArea, Country: $country, Final: $city');
                } else {
                  // If no locality, try to use administrative area + country
                  if (placemark.administrativeArea != null && placemark.administrativeArea!.isNotEmpty) {
                    if (placemark.country != null && placemark.country!.isNotEmpty) {
                      city = '${placemark.administrativeArea}, ${placemark.country}';
                    } else {
                      city = placemark.administrativeArea!;
                    }
                  } else if (placemark.country != null && placemark.country!.isNotEmpty) {
                    city = placemark.country!;
                  }
                }
              }
            } catch (e) {
              debugPrintIfDebugging('Geolocation timeout or error: $e');
            }
          }
        }
      } catch (e) {
        debugPrintIfDebugging('Geolocation failed, falling back to $city: $e');
      }
      
      // Validate and clean up the city string
      city = _cleanupLocationString(city);
      
      // Additional validation to catch obviously wrong locations
      if (_isLocationSuspicious(city)) {
        debugPrintIfDebugging('Suspicious location detected: $city, falling back to default');
        city = 'London, UK';
      }
      
      debugPrintIfDebugging('_determineLocation: Final city: $city');
      
      // Update the UI with the determined location
      setState(() {
        _determinedLocation = city; // Full location for API
        _displayLocation = _extractDisplayLocation(city); // Short location for display
        _isLocationDetermined = true;
        _locationDeterminedAt = DateTime.now(); // Record when location was determined
      });
      
      // Reset loading message timer to start temperature-related messages
      _loadingElapsedSeconds = 0;
      _updateLoadingMessage();
      
    } catch (e) {
      debugPrintIfDebugging('_determineLocation failed: $e');
      // Set default location if everything fails
      setState(() {
        _determinedLocation = 'London, UK';
        _displayLocation = _extractDisplayLocation('London, UK');
        _isLocationDetermined = true;
        _locationDeterminedAt = DateTime.now(); // Record when location was determined
      });
      
      // Reset loading message timer to start temperature-related messages
      _loadingElapsedSeconds = 0;
      _updateLoadingMessage();
    }
  }

  void _startLoadingMessageTimer() {
    _loadingElapsedSeconds = 0;
    _updateLoadingMessage();
    
    _loadingMessageTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      _loadingElapsedSeconds++;
      _updateLoadingMessage();
    });
  }

  void _stopLoadingMessageTimer() {
    _loadingMessageTimer?.cancel();
    _loadingMessageTimer = null;
  }

  void _startDateCheckTimer() {
    // Check immediately on startup
    _checkDateChange();
    
    // Then check every minute
    _dateCheckTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkDateChange();
    });
  }

  String _extractDisplayLocation(String fullLocation) {
    if (fullLocation.isEmpty) return '';
    
    // Split by comma and take the first part (city)
    final parts = fullLocation.split(',');
    if (parts.isNotEmpty) {
      return parts.first.trim();
    }
    
    return fullLocation;
  }

  void _checkDateChange() {
    final now = DateTime.now();
    final useYesterday = now.hour < kUseYesterdayHourThreshold;
    final currentDate = useYesterday ? now.subtract(Duration(days: 1)) : now;
    
    if (_lastCheckedDate == null) {
      _lastCheckedDate = currentDate;
      return;
    }
    
    // Check if the date has changed (ignoring time)
    if (_lastCheckedDate!.year != currentDate.year ||
        _lastCheckedDate!.month != currentDate.month ||
        _lastCheckedDate!.day != currentDate.day) {
      debugPrintIfDebugging('Date changed from ${_lastCheckedDate} to $currentDate, reloading data');
      
      // Only reload if we're not already loading fresh data
      if (!_isShowingCachedData) {
        _isDataLoading = true;
        
        // Start progressive loading in the background
        _loadChartDataProgressive();
        
        // Restart loading message timer for date change reload
        _startLoadingMessageTimer();
      }
    }
    
    _lastCheckedDate = currentDate;
  }

  void _updateLoadingMessage() {
    if (!mounted) return;
    
    String newMessage;
    
    // Only show temperature-related messages if location has been determined
    if (!_isLocationDetermined) {
      if (_loadingElapsedSeconds < 5) {
        newMessage = 'Determining your location...';
      } else if (_loadingElapsedSeconds < 15) {
        newMessage = 'Getting your location from GPS...';
      } else if (_loadingElapsedSeconds < 30) {
        newMessage = 'Still determining your location...';
      } else {
        newMessage = 'Location detection is taking longer than expected.';
      }
    } else {
      // Location is determined, show temperature-related messages
      if (_loadingElapsedSeconds < 10) {
        newMessage = 'Loading temperature data...';
      } else if (_loadingElapsedSeconds < 25) {
        // Calculate the date that will be used (same logic as _loadChartData)
        final now = DateTime.now();
        final useYesterday = now.hour < kUseYesterdayHourThreshold;
        final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
        final friendlyDate = _formatDayMonth(dateToUse);
        newMessage = 'Getting temperatures on $friendlyDate over the past 50 years.';
      } else if (_loadingElapsedSeconds < 45) {
        // Use the display location if available
        final locationText = _displayLocation.isNotEmpty ? _displayLocation : 'your area';
        newMessage = 'Is today warmer than average in $locationText?';
      } else if (_loadingElapsedSeconds < 60) {
        newMessage = 'Once we have the data we\'ll know.';
      } else if (_loadingElapsedSeconds < 80) {
        newMessage = 'Please be patient. It shouldn\'t be much longer.';
      } else {
        newMessage = 'The server is taking a while to respond.';
      }
    }
    
    if (newMessage != _currentLoadingMessage) {
      setState(() {
        _currentLoadingMessage = newMessage;
      });
    }
  }

  Future<void> _loadChartDataProgressive() async {
    debugPrintIfDebugging('_loadChartDataProgressive: Starting progressive chart data load');
    
    try {
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final formattedDate = DateFormat('yyyy-MM-dd').format(dateToUse);
      debugPrintIfDebugging('_loadChartDataProgressive: Current time: ${now.hour}:${now.minute}, useYesterday: $useYesterday, dateToUse: $formattedDate');

      final service = TemperatureService();
      String city = _determinedLocation.isNotEmpty ? _determinedLocation : 'London, UK';
      
      debugPrintIfDebugging('_loadChartDataProgressive: Using determined city: $city');
      final currentYear = dateToUse.year;

      // Skip main /data/ endpoint for progressive loading to ensure year-by-year loading is visible
      // This forces the fallback method which loads data progressively
      debugPrintIfDebugging('_loadChartDataProgressive: Skipping main endpoint to force progressive loading');

      // Fallback: use individual endpoints with progressive loading
      debugPrintIfDebugging('Using fallback endpoints for $city, $formattedDate');
      
      final mmdd = formattedDate.substring(5);
      double? averageTemperature;
      double? trendSlope;
      String? summaryText;
      int startYear = currentYear - 50;
      int endYear = currentYear;
      
      // Get average data first
      try {
        final averageData = await service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: 30));
        averageTemperature = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
        
        if (averageData['year_range'] != null) {
          final yearRange = averageData['year_range'];
          if (yearRange is Map<String, dynamic>) {
            final start = yearRange['start'];
            final end = yearRange['end'];
            if (start is int && end is int) {
              startYear = start;
              endYear = end;
            }
          }
        }
      } catch (e) {
        debugPrintIfDebugging('Failed to fetch average data: $e');
        setState(() {
          _averageDataFailed = true;
          if (e is RateLimitException) {
            _averageDataRateLimited = true;
          }
        });
      }
      
      // Get trend data
      try {
        final trendData = await service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: 30));
        final slope = trendData['slope'];
        trendSlope = (slope is num) ? slope.toDouble() : null;
      } catch (e) {
        debugPrintIfDebugging('Failed to fetch trend data: $e');
        setState(() {
          _trendDataFailed = true;
          if (e is RateLimitException) {
            _trendDataRateLimited = true;
          }
        });
      }
      
      // Get summary data
      try {
        final summaryData = await service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: 30));
        final summaryRaw = summaryData['summary'];
        summaryText = summaryRaw?.toString();
      } catch (e) {
        debugPrintIfDebugging('Failed to fetch summary data: $e');
        setState(() {
          _summaryDataFailed = true;
          if (e is RateLimitException) {
            _summaryDataRateLimited = true;
          }
        });
      }
      
      // Calculate final year range
      final finalStartYear = startYear < 1975 ? 1975 : startYear;
      final finalEndYear = endYear > currentYear ? currentYear : endYear;
      
      // Start with empty chart data - bars will be added progressively
      List<TemperatureChartData> chartData = [];
      
      // Set initial result with empty chart data
      final initialResult = _createResultMap(
        chartData: chartData,
        averageTemperature: averageTemperature,
        trendSlope: trendSlope,
        summaryText: summaryText,
        dateToUse: dateToUse,
        city: city,
      );
      _currentData = initialResult;
      
      // Update the UI to show the chart structure
      if (mounted) {
        setState(() {});
      }
      
      // Load from most recent to oldest (2025 -> 1975) to create right-to-left filling effect
      for (int year = finalEndYear; year >= finalStartYear; year--) {
        // Check if we've hit a rate limit - stop making more requests
        if (_chartDataRateLimited) {
          debugPrintIfDebugging('Rate limit detected, stopping chart data loading');
          break;
        }
        
        final dateForYear = '$year-$mmdd';
        try {
          final tempData = await service.fetchTemperature(city, dateForYear);
          
          // Add the new data point to the chart data
          final newDataPoint = TemperatureChartData(
            year: year.toString(),
            temperature: tempData.temperature ?? tempData.average?.temperature ?? 0.0,
            isCurrentYear: year == currentYear,
            hasData: true,
          );
          
          // Add to the chart data list
          chartData.add(newDataPoint);
          
          // Update the current data and trigger a rebuild
          _currentData!['chartData'] = chartData;
          
          // Trigger a UI update to show the new bar
          if (mounted) {
            setState(() {});
          }
          
          debugPrintIfDebugging('Added data for year $year at index ${chartData.length - 1}');
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch temperature for year $year: $e');
          
          // Check if it's a rate limit error
          if (e is RateLimitException) {
            debugPrintIfDebugging('Rate limit exceeded for chart data, stopping further requests');
            setState(() {
              _chartDataRateLimited = true;
            });
            break; // Stop making more requests
          }
          
          // Don't add missing data points to the chart - they won't be visible anyway
        }
        
        // Add a delay to make progressive loading more visible
        await Future.delayed(const Duration(milliseconds: 300));
      }
      
      // Stop loading message timer when data loading completes
      _stopLoadingMessageTimer();
      _isDataLoading = false;
      
      // Start auto-retry timer if there are failed endpoints
      if (_averageDataFailed || _trendDataFailed || _summaryDataFailed) {
        _startAutoRetryTimer();
      }
      
    } catch (e) {
      debugPrintIfDebugging('_loadChartDataProgressive failed: $e');
      
      // Stop loading message timer on error
      _stopLoadingMessageTimer();
      _isDataLoading = false;
      
      rethrow;
    }
  }



  Future<void> _cacheChartData(Map<String, dynamic> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Validate that chartData exists and is a List
      final chartData = data['chartData'];
      if (chartData == null || chartData is! List<TemperatureChartData>) {
        debugPrintIfDebugging('Invalid chartData for caching, skipping cache');
        return;
      }
      
      // Calculate the date that was used for this data (same logic as _loadChartData)
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      
      // Only cache the minimal necessary data
      final cache = jsonEncode({
        'chartData': chartData.map((e) => {
          'year': e.year,
          'temperature': e.temperature,
          'isCurrentYear': e.isCurrentYear,
        }).toList(),
        'averageTemperature': data['averageTemperature'],
        'trendSlope': data['trendSlope'],
        'summary': data['summary'],
        'displayDate': data['displayDate'],
        'city': data['city'],
        'cachedDate': DateFormat('yyyy-MM-dd').format(dateToUse), // Store the date that was actually used for the data
      });
      await prefs.setString('cachedChartData', cache);
    } catch (e) {
      debugPrintIfDebugging('Error caching data: $e');
      // Don't throw, just log the error
    }
  }

  Future<Map<String, dynamic>?> _loadCachedChartData() async {
    final prefs = await SharedPreferences.getInstance();
    final cache = prefs.getString('cachedChartData');
    if (cache == null) return null;
    
    try {
      final decoded = jsonDecode(cache);
      
      // Validate that decoded is a Map
      if (decoded == null || decoded is! Map<String, dynamic>) {
        debugPrintIfDebugging('Cached data is not a valid Map, clearing cache');
        await prefs.remove('cachedChartData');
        return null;
      }
      
      // Check if the date has changed since the data was cached
      final cachedDate = decoded['cachedDate'] as String?;
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold; // Use same logic as _loadChartDataR
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final currentDate = DateFormat('yyyy-MM-dd').format(dateToUse);
      
      if (cachedDate != null && cachedDate != currentDate) {
        // Date has changed, but we'll still use cached data as fallback
        // The fresh data load will be attempted first, and if it fails, we'll fall back to cached
        debugPrintIfDebugging('Date changed from $cachedDate to $currentDate, but keeping cached data as fallback');
        // Don't return null here - let the caller decide whether to use cached data
      }
      
      // Safely extract chartData
      final chartDataRaw = decoded['chartData'];
      if (chartDataRaw == null || chartDataRaw is! List) {
        debugPrintIfDebugging('Cached chartData is invalid, clearing cache');
        await prefs.remove('cachedChartData');
        return null;
      }
      
      final chartDataList = chartDataRaw.map((e) {
        // Validate each chart data item
        if (e == null || e is! Map<String, dynamic>) {
          throw Exception('Invalid chart data item in cache');
        }
        
        return TemperatureChartData(
          year: e['year']?.toString() ?? '',
          temperature: (e['temperature'] is num) ? (e['temperature'] as num).toDouble() : 0.0,
          isCurrentYear: e['isCurrentYear'] == true,
        );
      }).toList();
      
      return {
        'chartData': chartDataList,
        'averageTemperature': decoded['averageTemperature'],
        'trendSlope': decoded['trendSlope'],
        'summary': decoded['summary'],
        'displayDate': decoded['displayDate'],
        'city': decoded['city'],
        'cachedDate': cachedDate, // Include the cached date for reference
      };
    } catch (e) {
      debugPrintIfDebugging('Error loading cached data: $e');
      // Clear corrupted cache
      await prefs.remove('cachedChartData');
      return null;
    }
  }

  Future<Map<String, dynamic>> _cacheAndReturnResult(Map<String, dynamic> result) async {
    await _cacheChartData(result);
    return result;
  }

  Future<void> _handleRefresh() async {
    debugPrintIfDebugging('Pull-to-refresh triggered');
    
    // Cancel any existing background refresh to prevent race conditions
    if (_isShowingCachedData) {
      _isShowingCachedData = false;
    }
    
    // Stop any existing auto-retry timer
    _stopAutoRetryTimer();
    
    // Reset error states
    _resetErrorStates();
    
    // Clear cache in simulation mode to ensure fresh data loading
    if (SIMULATE_ENDPOINT_FAILURES) {
      await _clearCache();
    }
    
    // Reset location determination state
    setState(() {
      _isLocationDetermined = false;
      _determinedLocation = '';
      _displayLocation = '';
      _locationDeterminedAt = null;
    });
    
    // Reinitialize the app (determine location then load data)
    await _initializeApp();
    
    // Don't await the future here - let the FutureBuilder handle it
    // This allows the RefreshIndicator to complete its animation
  }

  Widget _buildRefreshIndicator(Widget child) {
    debugPrintIfDebugging('_buildRefreshIndicator: futureChartData=${futureChartData != null}, _isDataLoading=$_isDataLoading');
    
    // Always show RefreshIndicator when we have data
    if (futureChartData == null) {
      debugPrintIfDebugging('_buildRefreshIndicator: No data, returning child without RefreshIndicator');
      return child;
    }
    
    // Show RefreshIndicator with refresh function
    debugPrintIfDebugging('_buildRefreshIndicator: Showing RefreshIndicator');
    return RefreshIndicator(
      onRefresh: _handleRefresh,
      color: kAccentColour,
      backgroundColor: kBackgroundColour,
      child: child,
    );
  }

  Widget _buildFutureBuilder({required double chartHeight}) {
    // Show loading section if we don't have any data yet
    if (_currentData == null) {
      return _buildLoadingSection();
    }
    
    final data = _currentData!;
    final chartData = data['chartData'] as List<TemperatureChartData>;
    
    // If we're loading and have no data yet, show loading state
    if (chartData.isEmpty && _isDataLoading) {
      return _buildChartWithEmptyBars(
        chartData, 
        data['averageTemperature'] as double?, 
        data['trendSlope'] as double?, 
        data['summary'] as String?, 
        data['displayDate'] as String?, 
        _displayLocation.isNotEmpty ? _displayLocation : (data['city'] as String?), 
        chartHeight, 
        _isShowingCachedData, 
        data['cachedDate'] as String?
      );
    }
    
    // Show no chart data state with retry button (only if we have no data at all and not loading)
    if (chartData.isEmpty && !_isDataLoading) {
      final isRateLimited = _averageDataRateLimited || _trendDataRateLimited || _summaryDataRateLimited || _chartDataRateLimited;
      
      return _buildRetrySection(
        isRateLimited 
          ? 'API rate limit exceeded. Please wait a few minutes before trying again.'
          : 'No temperature data available. Please check your internet connection and try again.',
        isRateLimited ? null : () {
          debugPrintIfDebugging('Retry button pressed after no data');
          _handleRefresh();
        },
      );
    }
    
    // Filter to only show bars with actual data for the chart display
    final validChartData = chartData.where((data) => 
      data.hasData && 
      data.temperature.isFinite && 
      data.temperature.abs() < 100 // Reasonable temperature range
    ).toList();
    
    final averageTemperature = data['averageTemperature'] as double?;
    final trendSlope = data['trendSlope'] as double?;
    final summaryText = data['summary'] as String?;
    final displayDate = data['displayDate'] as String?;
    // Use display location instead of full location from API data
    final city = _displayLocation.isNotEmpty ? _displayLocation : (data['city'] as String?);
    
    debugPrintIfDebugging('Average temperature for plot band: $averageTemperature°C');
    debugPrintIfDebugging('Summary text for UI: $summaryText');
    debugPrintIfDebugging('Summary text is empty: ${summaryText?.isEmpty}');
    debugPrintIfDebugging('Summary text is null: ${summaryText == null}');

    return _buildChartContent(
      chartData: chartData, // Pass all chart data (including empty placeholders)
      averageTemperature: averageTemperature,
      trendSlope: trendSlope,
      summaryText: summaryText,
      displayDate: displayDate,
      city: city,
      chartHeight: chartHeight,
      isCachedData: _isShowingCachedData,
      cachedDate: data['cachedDate'] as String?,
    );
  }

  Widget _buildRetryButton(VoidCallback onPressed) {
    return ElevatedButton(
      onPressed: onPressed,
      child: const Text(
        'Retry',
        style: TextStyle(color: kTextPrimaryColour),
      ),
      style: ElevatedButton.styleFrom(
        backgroundColor: kAccentColour,
      ),
    );
  }

  Widget _buildRetrySection(String message, VoidCallback? onRetry) {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Center(
          child: Container(
            width: contentWidth,
            margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  message,
                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody),
                  textAlign: TextAlign.left,
                ),
                if (onRetry != null) ...[
                  const SizedBox(height: 16),
                  _buildRetryButton(onRetry),
                ],
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildNoDataSection() {
    // Check if we're rate limited
    final isRateLimited = _averageDataRateLimited || _trendDataRateLimited || _summaryDataRateLimited || _chartDataRateLimited;
    
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Center(
          child: Container(
            width: contentWidth,
            margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  isRateLimited 
                    ? 'API rate limit exceeded'
                    : 'No temperature data available for this location.',
                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody),
                  textAlign: TextAlign.left,
                ),
                const SizedBox(height: 8),
                Text(
                  isRateLimited
                    ? 'Too many requests have been made. Please wait a few minutes before trying again.'
                    : 'This could be due to rate limiting or insufficient historical data for this area.',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 1),
                  textAlign: TextAlign.left,
                ),
                if (isRateLimited) ...[
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Icon(
                        Icons.timer,
                        color: kGreyLabelColour,
                        size: 16,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'Rate limits typically reset after 1 hour. You can try refreshing later.',
                          style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2),
                          textAlign: TextAlign.left,
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildLoadingSection() {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Container(
          width: contentWidth,
          margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start, // Left align like other content
            children: [
              // Date section - show as soon as we have it
              _buildLoadingDateSection(),
              
              // Location section - show the determined location
              if (_isLocationDetermined)
                _buildDeterminedLocationSection()
              else
                _buildLocationDeterminingSection(),
              
              // Progressive loading messages - show below location
              if (_isLocationDetermined)
                _buildProgressiveLoadingSection(),
            ],
          ),
        );
      },
    );
  }

  Widget _buildLoadingDateSection() {
    // Calculate the date that will be used (same logic as _loadChartData)
    final now = DateTime.now();
    final useYesterday = now.hour < kUseYesterdayHourThreshold;
    final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
    final displayDate = _formatDayMonth(dateToUse);
    
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Text(
        displayDate,
        style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
        textAlign: TextAlign.left,
      ),
    );
  }

  Widget _buildDeterminedLocationSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Align(
        alignment: Alignment.centerLeft,
        child: Container(
          margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
          child: Text(
            _displayLocation,
            style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
            textAlign: TextAlign.left,
          ),
        ),
      ),
    );
  }

  Widget _buildLocationDeterminingSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  color: kGreyLabelColour,
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  'Determining your location...',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 1, fontWeight: FontWeight.w400),
                  textAlign: TextAlign.left,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          Text(
            'Once we know your location, we\'ll fetch temperature data for your area.',
            style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2),
            textAlign: TextAlign.left,
          ),
        ],
      ),
    );
  }

  Widget _buildProgressiveLoadingSection() {
    return Padding(
      padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
      child: Align(
        alignment: Alignment.centerLeft,
        child: Container(
          margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
          child: Row(
            children: [
              const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  color: kGreyLabelColour,
                ),
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  _currentLoadingMessage.isNotEmpty 
                    ? _currentLoadingMessage 
                    : 'Loading temperature data...',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 1, fontWeight: FontWeight.w400),
                  textAlign: TextAlign.left,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGradientBackground() {
    return SizedBox.expand(
      child: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Color(0xFF242456), // Top color
              Color(0xFF343499), // Bottom color
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTitleLogoSection() {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        debugPrintIfDebugging('Title area - Screen width: ${constraints.maxWidth}, contentWidth: $contentWidth, horizontalOffset: $horizontalOffset, isWideScreen: ${constraints.maxWidth >= 600}');
        
        return Padding(
          padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
          child: Stack(
            children: [
              // Logo positioned to the left of content area
              if (horizontalOffset > 0)
                Positioned(
                  left: horizontalOffset - 60, // Position logo 60px to the left of content (50px + 10px for bar alignment)
                  child: SvgPicture.asset(
                    'assets/logo.svg',
                    width: 40,
                    height: 40,
                  ),
                ),
              // Title text aligned with content left edge
              Align(
                alignment: Alignment.centerLeft,
                child: Container(
                  margin: EdgeInsets.only(
                    left: horizontalOffset > 0 ? horizontalOffset : kTitleRowHorizontalMargin,
                  ),
                  child: Row(
                    children: [
                      // Only show logo inline on narrow screens
                      if (horizontalOffset <= 0)
                        Padding(
                          padding: const EdgeInsets.only(right: kTitleRowIconRightPadding),
                          child: SvgPicture.asset(
                            'assets/logo.svg',
                            width: 40,
                            height: 40,
                          ),
                        ),
                      Text(
                        'TempHist',
                        style: TextStyle(
                          color: kAccentColour,
                          fontSize: kFontSizeTitle,
                          fontWeight: FontWeight.bold,
                          letterSpacing: 1.2,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildVersionSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: LayoutBuilder(
        builder: (context, constraints) {
          double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
          double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
          
          return Align(
            alignment: Alignment.centerLeft,
            child: Container(
              margin: EdgeInsets.only(
                left: horizontalOffset > 0 ? horizontalOffset : kTitleRowHorizontalMargin,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Debug Info:',
                    style: TextStyle(
                      color: kGreyLabelColour,
                      fontSize: kFontSizeBody - 2,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'Version: ${AppConfig.fullVersion}',
                    style: TextStyle(
                      color: kGreyLabelColour,
                      fontSize: kFontSizeBody - 3,
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                  Text(
                    'Release: ${AppConfig.releaseDate}',
                    style: TextStyle(
                      color: kGreyLabelColour,
                      fontSize: kFontSizeBody - 3,
                      fontWeight: FontWeight.w400,
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildDebugToggleSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: LayoutBuilder(
        builder: (context, constraints) {
          double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
          double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
          
          return Align(
            alignment: Alignment.centerLeft,
            child: Container(
              margin: EdgeInsets.only(
                left: horizontalOffset > 0 ? horizontalOffset : kTitleRowHorizontalMargin,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Debug Mode - Simulate Endpoint Failures:',
                    style: TextStyle(
                      color: kGreyLabelColour,
                      fontSize: kFontSizeBody - 1,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 8),
                  // Use Wrap for responsive button layout
                  Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: [
                      _buildDebugToggleButton('Average', 'average'),
                      _buildDebugToggleButton('Trend', 'trend'),
                      _buildDebugToggleButton('Summary', 'summary'),
                      _buildResetAllButton(),
                    ],
                  ),
                  if (SIMULATE_ENDPOINT_FAILURES) ...[
                    const SizedBox(height: 8),
                    Text(
                      'Simulation Active: ${_simulateAverageFailure ? "Average" : ""}${_simulateTrendFailure ? (_simulateAverageFailure ? ", " : "") + "Trend" : ""}${_simulateSummaryFailure ? ((_simulateAverageFailure || _simulateTrendFailure) ? ", " : "") + "Summary" : ""}',
                      style: TextStyle(
                        color: kAccentColour,
                        fontSize: kFontSizeBody - 2,
                        fontWeight: FontWeight.w400,
                      ),
                    ),
                  ],
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildDebugToggleButton(String label, String endpoint) {
    bool isSimulating = false;
    
    switch (endpoint) {
      case 'average':
        isSimulating = _simulateAverageFailure;
        break;
      case 'trend':
        isSimulating = _simulateTrendFailure;
        break;
      case 'summary':
        isSimulating = _simulateSummaryFailure;
        break;
    }
    
    return GestureDetector(
      onTap: () async {
        setState(() {
          switch (endpoint) {
            case 'average':
              _simulateAverageFailure = !_simulateAverageFailure;
              break;
            case 'trend':
              _simulateTrendFailure = !_simulateTrendFailure;
              break;
            case 'summary':
              _simulateSummaryFailure = !_simulateSummaryFailure;
              break;
          }
        });
        
        // Show feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${isSimulating ? 'Disabled' : 'Enabled'} $label failure simulation'),
            duration: const Duration(seconds: 1),
          ),
        );
        
        // If we're enabling a simulation, trigger a refresh to see the failure
        if (!isSimulating) {
          // Clear cache when enabling simulation to ensure fresh data loading
          await _clearCache();
          _handleRefresh();
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: isSimulating ? kAccentColour : kGreyLabelColour.withOpacity(0.3),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          label,
          style: TextStyle(
            color: isSimulating ? Colors.white : kGreyLabelColour,
            fontSize: kFontSizeBody - 2,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildResetAllButton() {
    return GestureDetector(
      onTap: () {
        setState(() {
          _simulateAverageFailure = true;
          _simulateTrendFailure = false;
          _simulateSummaryFailure = false;
        });
        // Show feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('All failure simulations reset'),
            duration: const Duration(seconds: 1),
          ),
        );
        // If we're enabling a simulation, trigger a refresh to see the failure
        _handleRefresh();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: kGreyLabelColour.withOpacity(0.3),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          'Reset All',
          style: TextStyle(
            color: kGreyLabelColour,
            fontSize: kFontSizeBody - 2,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildContentPadding(BuildContext context, Widget child) {
    return Padding(
      padding: EdgeInsets.only(
        top: MediaQuery.of(context).padding.top + kContentVerticalPadding,
        bottom: MediaQuery.of(context).padding.bottom + kContentVerticalPadding,
        left: kScreenPadding,
        right: kScreenPadding,
      ),
      child: child,
    );
  }

  Widget _buildChartWithEmptyBars(
    List<TemperatureChartData> chartData,
    double? averageTemperature,
    double? trendSlope,
    String? summaryText,
    String? displayDate,
    String? city,
    double chartHeight,
    bool isCachedData,
    String? cachedDate,
  ) {
    // Show a loading state with the chart structure but no visible bars
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(kChartInnerPadding),
        child: LayoutBuilder(
          builder: (context, constraints) {
            double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth - 20 : 580;
            return Center(
              child: Container(
                width: contentWidth,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Date and location above summary
                    if (displayDate != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kSectionHorizontalMargin),
                            child: Text(
                              isCachedData && cachedDate != null 
                                ? _formatDayMonth(DateFormat('yyyy-MM-dd').parse(cachedDate))
                                : displayDate,
                              style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    if (city != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Text(
                                  city,
                                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                  textAlign: TextAlign.left,
                                ),
                                if (isCachedData)
                                  Padding(
                                    padding: const EdgeInsets.only(left: 8.0),
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 6.0, vertical: 2.0),
                                      decoration: BoxDecoration(
                                        color: kGreyLabelColour.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(4.0),
                                      ),
                                      child: Text(
                                        'cached',
                                        style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                                        textAlign: TextAlign.left,
                                      ),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    if (summaryText?.isNotEmpty == true)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              summaryText!,
                              style: TextStyle(color: kSummaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    // Show loading message instead of chart
                    SizedBox(
                      height: chartHeight,
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const CircularProgressIndicator(
                              color: kGreyLabelColour,
                            ),
                            const SizedBox(height: 16),
                            Text(
                              'Loading temperature data...',
                              style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildChartContent({
    required List<TemperatureChartData> chartData,
    required double? averageTemperature,
    required double? trendSlope,
    required String? summaryText,
    required String? displayDate,
    required String? city,
    required double chartHeight,
    bool isCachedData = false,
    String? cachedDate,
  }) {
    // Calculate minimum and maximum temperature for Y-axis (only from years with data)
    final validData = chartData.where((data) => data.hasData).toList();
    
    // If we have chart data but no valid data yet, show the chart with empty bars
    // This allows the progressive loading to be visible
    if (validData.isEmpty) {
      // Show chart with empty bars - they won't be visible but the structure will be there
      return _buildChartWithEmptyBars(chartData, averageTemperature, trendSlope, summaryText, displayDate, city, chartHeight, isCachedData, cachedDate);
    }
    
    double yAxisMin;
    double yAxisMax;
    double minTemp = 0.0;
    double maxTemp = 0.0;
    
    minTemp = validData.map((data) => data.temperature).reduce((a, b) => a < b ? a : b);
    maxTemp = validData.map((data) => data.temperature).reduce((a, b) => a > b ? a : b);
    
    // Calculate dynamic Y-axis range based on actual data
    // Add padding above and below the data range for better visualization
    yAxisMin = (minTemp - 2).floorToDouble(); // Start 2 degrees below minimum
    yAxisMax = (maxTemp + 2).ceilToDouble(); // End 2 degrees above maximum
    
    // Ensure we have a reasonable minimum range even for small temperature variations
    final range = maxTemp - minTemp;
    if (range < 5) {
      // For small ranges, ensure we have at least 5 degrees of scale
      final midPoint = (maxTemp + minTemp) / 2;
      yAxisMin = (midPoint - 2.5).floorToDouble();
      yAxisMax = (midPoint + 2.5).ceilToDouble();
    }
    
    debugPrintIfDebugging('Y-axis calculation - minTemp: $minTemp, maxTemp: $maxTemp, yAxisMin: $yAxisMin, yAxisMax: $yAxisMax');
    debugPrintIfDebugging('_buildChartContent: summaryText = "$summaryText"');
    debugPrintIfDebugging('_buildChartContent: summaryText?.isNotEmpty = ${summaryText?.isNotEmpty}');
    debugPrintIfDebugging('_buildChartContent: kSummaryColour = $kSummaryColour');
    
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(kChartInnerPadding),
        child: LayoutBuilder(
          builder: (context, constraints) {
            // Reduce content width to provide more margin for chart labels
            double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth - 20 : 580;
            debugPrintIfDebugging('Main content - Screen width: ${constraints.maxWidth}, contentWidth: $contentWidth, isWideScreen: ${constraints.maxWidth >= 600}');
            return Center(
              child: Container(
                width: contentWidth,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Date and location above summary
                    if (displayDate != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kSectionHorizontalMargin),
                            child: Text(
                              isCachedData && cachedDate != null 
                                ? _formatDayMonth(DateFormat('yyyy-MM-dd').parse(cachedDate))
                                : displayDate,
                              style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    if (city != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Text(
                                  city,
                                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                  textAlign: TextAlign.left,
                                ),
                                if (isCachedData)
                                  Padding(
                                    padding: const EdgeInsets.only(left: 8.0),
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 6.0, vertical: 2.0),
                                      decoration: BoxDecoration(
                                        color: kGreyLabelColour.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(4.0),
                                      ),
                                      child: Text(
                                        'cached',
                                        style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                                        textAlign: TextAlign.left,
                                      ),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    if (summaryText?.isNotEmpty == true)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              summaryText!,
                              style: TextStyle(color: kSummaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    SizedBox(
                      height: chartHeight,
                      child: SfCartesianChart(
                        margin: EdgeInsets.only(
                          left: kChartHorizontalMargin, // Keep left margin consistent with text
                          right: kChartHorizontalMargin + 8, // Extra right margin for Y-axis labels
                        ),
                        tooltipBehavior: TooltipBehavior(
                          enable: true,
                          format: 'point.x: point.y°C',
                          canShowMarker: false,
                          header: '',
                          textStyle: TextStyle(fontSize: kFontSizeBody),
                          builder: (data, point, series, pointIndex, seriesIndex) {
                            final year = data.year;
                            final temp = data.temperature.toStringAsFixed(1);
                            return Container(
                              padding: const EdgeInsets.all(8),
                              decoration: BoxDecoration(
                                color: Colors.black87,
                                borderRadius: BorderRadius.circular(4),
                              ),
                              child: Text(
                                '$year: ${temp}°C',
                                style: const TextStyle(color: Colors.white, fontSize: 12),
                              ),
                            );
                          },
                        ),
                        series: [
                          BarSeries<TemperatureChartData, int>(
                            onRendererCreated: (ChartSeriesController controller) {
                              _chartSeriesController = controller;
                            },
                            dataSource: chartData,
                            xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                            yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                            pointColorMapper: (TemperatureChartData data, int index) =>
                                data.isCurrentYear ? kBarCurrentYearColour : kBarOtherYearColour,
                            width: 0.8, // Restored to proper thickness
                            name: 'Yearly Temperature',
                            enableTooltip: true,
                            // Ensure consistent spacing and prevent edge cropping
                            spacing: 0.1, // Reduced spacing to maintain bar thickness
                            borderRadius: BorderRadius.circular(2),
                          ),
                          if (averageTemperature != null)
                            LineSeries<TemperatureChartData, int>(
                              dataSource: _generateAverageData(chartData, averageTemperature),
                              xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                              yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                              color: kAverageColour,
                              width: 2,
                              name: 'Average Temperature',
                              markerSettings: MarkerSettings(isVisible: false),
                            ),
                          if (trendSlope != null)
                            LineSeries<TemperatureChartData, int>(
                              dataSource: _generateTrendData(chartData, trendSlope),
                              xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                              yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                              color: kTrendColour,
                              width: 2,
                              name: 'Trend',
                              markerSettings: MarkerSettings(isVisible: false),
                            ),
                        ],
                        primaryXAxis: NumericAxis(
                          labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                          majorGridLines: MajorGridLines(width: 0),
                          labelIntersectAction: AxisLabelIntersectAction.hide,
                          // For progressive loading, show the full year range (1975-2025) from the start
                          // This ensures consistent bar spacing as data loads and includes current year
                          minimum: 1975.0,
                          maximum: 2025.0,
                          interval: 5, // Show every 5th year to avoid crowding
                          labelFormat: '{value}',
                          // Ensure proper spacing and prevent cropping
                          plotOffset: 20,
                        ),
                        primaryYAxis: NumericAxis(
                          labelFormat: '{value}°C',
                          numberFormat: NumberFormat('0'),
                          minimum: yAxisMin,
                          maximum: yAxisMax,
                          majorGridLines: MajorGridLines(width: 0),
                          labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                          // Ensure bars start at the axis regardless of temperature values
                          plotOffset: 0,
                          // Force the axis to respect the exact minimum and maximum values
                          desiredIntervals: 5,
                          // Add margin for Y-axis labels
                          labelPosition: ChartDataLabelPosition.outside,
                        ),
                        plotAreaBorderWidth: 0,
                        enableAxisAnimation: false, // Disable animation to prevent "moving down" effect
                        // Ensure proper spacing for bars
                      ),
                    ),
                    // Consistent spacing below chart - always show this
                    const SizedBox(height: kSectionTopPadding),
                    // Average temperature text below chart
                    if (averageTemperature != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              'Average: ${averageTemperature.toStringAsFixed(1)}°C',
                              style: TextStyle(color: kAverageColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      )
                    else if (_averageDataFailed)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Icon(
                                  _isRetryingAverage ? Icons.hourglass_empty : 
                                  _averageDataRateLimited ? Icons.timer : Icons.error_outline,
                                  color: _isRetryingAverage ? kGreyLabelColour : 
                                         _averageDataRateLimited ? kGreyLabelColour : kAccentColour,
                                  size: 16,
                                ),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: Text(
                                    _isRetryingAverage 
                                      ? 'Retrying average temperature data...'
                                      : _averageDataRateLimited 
                                        ? 'Rate limit exceeded - please wait before retrying'
                                        : 'Failed to load average temperature data',
                                    style: TextStyle(
                                      color: _isRetryingAverage ? kGreyLabelColour : 
                                             _averageDataRateLimited ? kGreyLabelColour : kAccentColour, 
                                      fontSize: kFontSizeBody - 1, 
                                      fontWeight: FontWeight.w400
                                    ),
                                    textAlign: TextAlign.left,
                                  ),
                                ),
                                if (!_isRetryingAverage && !_averageDataRateLimited) ...[
                                  const SizedBox(width: 8),
                                  GestureDetector(
                                    onTap: _retryAverageData,
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                      decoration: BoxDecoration(
                                        color: kAccentColour.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(4),
                                      ),
                                      child: Text(
                                        'Retry',
                                        style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                                      ),
                                    ),
                                  ),
                                ],
                              ],
                            ),
                          ),
                        ),
                      ),
                    // Trend text below chart
                    if (trendSlope != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              trendSlope > 0 
                                ? 'Trend: Rising at ${trendSlope.abs().toStringAsFixed(1)}°C/decade'
                                : 'Trend: Falling at ${trendSlope.abs().toStringAsFixed(1)}°C/decade',
                              style: TextStyle(color: kTrendColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      )
                    else if (_trendDataFailed)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Icon(
                                  _isRetryingTrend ? Icons.hourglass_empty : Icons.error_outline,
                                  color: _isRetryingTrend ? kGreyLabelColour : kAccentColour,
                                  size: 16,
                                ),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: Text(
                                    _isRetryingTrend 
                                      ? 'Retrying trend data...'
                                      : _trendDataRateLimited 
                                        ? 'Rate limit exceeded - please wait before retrying'
                                        : 'Failed to load trend data',
                                    style: TextStyle(
                                      color: _isRetryingTrend ? kGreyLabelColour : 
                                             _trendDataRateLimited ? kGreyLabelColour : kAccentColour, 
                                      fontSize: kFontSizeBody - 1, 
                                      fontWeight: FontWeight.w400
                                    ),
                                    textAlign: TextAlign.left,
                                  ),
                                ),
                                if (!_isRetryingTrend && !_trendDataRateLimited) ...[
                                  const SizedBox(width: 8),
                                  GestureDetector(
                                    onTap: _retryTrendData,
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                      decoration: BoxDecoration(
                                        color: kAccentColour.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(4),
                                      ),
                                      child: Text(
                                        'Retry',
                                        style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                                      ),
                                    ),
                                  ),
                                ],
                              ],
                            ),
                          ),
                        ),
                      ),
                    // Summary error message if it failed
                    if (_summaryDataFailed)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Icon(
                                  _isRetryingSummary ? Icons.hourglass_empty : Icons.error_outline,
                                  color: _isRetryingSummary ? kGreyLabelColour : kAccentColour,
                                  size: 16,
                                ),
                                const SizedBox(width: 8),
                                Expanded(
                                  child: Text(
                                    _isRetryingSummary 
                                      ? 'Retrying summary data...'
                                      : _summaryDataRateLimited 
                                        ? 'Rate limit exceeded - please wait before retrying'
                                        : 'Failed to load summary data',
                                    style: TextStyle(
                                      color: _isRetryingSummary ? kGreyLabelColour : 
                                             _summaryDataRateLimited ? kGreyLabelColour : kAccentColour, 
                                      fontSize: kFontSizeBody - 1, 
                                      fontWeight: FontWeight.w400
                                    ),
                                    textAlign: TextAlign.left,
                                  ),
                                ),
                                if (!_isRetryingSummary && !_summaryDataRateLimited) ...[
                                  const SizedBox(width: 8),
                                  GestureDetector(
                                    onTap: _retrySummaryData,
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                      decoration: BoxDecoration(
                                        color: kAccentColour.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(4),
                                      ),
                                      child: Text(
                                        'Retry',
                                        style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                                      ),
                                    ),
                                  ),
                                ],
                              ],
                            ),
                          ),
                        ),
                      ),
                    // Data completeness indicator
                    _buildDataCompletenessIndicator(chartData),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildDataCompletenessIndicator(List<TemperatureChartData> chartData) {
    // Only show completeness indicator if we're not currently loading data
    if (_isDataLoading) {
      return const SizedBox.shrink();
    }
    
    final missingYears = chartData.where((data) => !data.hasData).map((data) => int.parse(data.year)).toList();
    final hasGaps = missingYears.isNotEmpty || _chartDataHasGaps;
    
    // Check for missing recent years (2022-2025)
    final currentYear = DateTime.now().year;
    final recentYears = List.generate(currentYear - 2021, (index) => 2022 + index);
    final missingRecentYears = recentYears.where((year) => 
      !chartData.any((data) => int.parse(data.year) == year && data.hasData)
    ).toList();
    
    if (hasGaps || missingRecentYears.isNotEmpty) {
      // Sort missing years for better display
      missingYears.sort();
      
      // Group consecutive missing years for cleaner display
      final missingRanges = _groupConsecutiveYears(missingYears);
      
      String missingText;
      if (missingRanges.length == 1 && missingRanges.first.length == 1) {
        // Single year missing
        missingText = 'Year ${missingRanges.first.first} is missing';
      } else if (missingRanges.length == 1) {
        // Consecutive years missing
        missingText = 'Years ${missingRanges.first.first}-${missingRanges.first.last} are missing';
      } else {
        // Multiple ranges missing
        final ranges = missingRanges.map((range) {
          if (range.length == 1) return range.first.toString();
          return '${range.first}-${range.last}';
        }).join(', ');
        missingText = 'Years $ranges are missing';
      }
      
      // Add note about missing recent years if applicable
      if (missingRecentYears.isNotEmpty) {
        final recentRanges = _groupConsecutiveYears(missingRecentYears);
        String recentText;
        if (recentRanges.length == 1 && recentRanges.first.length == 1) {
          recentText = 'Year ${recentRanges.first.first}';
        } else if (recentRanges.length == 1) {
          recentText = 'Years ${recentRanges.first.first}-${recentRanges.first.last}';
        } else {
          final ranges = recentRanges.map((range) {
            if (range.length == 1) return range.first.toString();
            return '${range.first}-${range.last}';
          }).join(', ');
          recentText = 'Years $ranges';
        }
        
        if (missingText.isNotEmpty) {
          missingText += '. Recent data ($recentText) is not yet available';
        } else {
          missingText = 'Recent data ($recentText) is not yet available';
        }
      }
      
      return Padding(
        padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
        child: Align(
          alignment: Alignment.centerLeft,
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Note: $missingText.',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                  textAlign: TextAlign.left,
                ),
                const SizedBox(height: 4),
                Text(
                  'Data completeness: ${((chartData.where((data) => data.hasData).length / chartData.length) * 100).toStringAsFixed(0)}%',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                  textAlign: TextAlign.left,
                ),
                if (_chartDataRetryCount < _maxChartDataRetries) ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Icon(
                        _isRetryingChartData ? Icons.hourglass_empty : Icons.refresh,
                        color: _isRetryingChartData ? kGreyLabelColour : kAccentColour,
                        size: 16,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          _isRetryingChartData 
                            ? 'Retrying chart data...'
                            : 'Missing data may be temporary. Try refreshing.',
                          style: TextStyle(
                            color: _isRetryingChartData ? kGreyLabelColour : kGreyLabelColour, 
                            fontSize: kFontSizeBody - 2, 
                            fontWeight: FontWeight.w400
                          ),
                          textAlign: TextAlign.left,
                        ),
                      ),
                      if (!_isRetryingChartData) ...[
                        const SizedBox(width: 8),
                        GestureDetector(
                          onTap: _retryChartData,
                          child: Container(
                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                            decoration: BoxDecoration(
                              color: kAccentColour.withOpacity(0.2),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'Retry',
                              style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                  if (_chartDataRetryCount > 0) ...[
                    const SizedBox(height: 4),
                    Text(
                      'Retry attempts: $_chartDataRetryCount/$_maxChartDataRetries',
                      style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 3, fontWeight: FontWeight.w400),
                      textAlign: TextAlign.left,
                    ),
                  ],
                ] else ...[
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      Icon(
                        Icons.info_outline,
                        color: kGreyLabelColour,
                        size: 16,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          'Data appears to be genuinely incomplete for this location. Some years may not have historical data available.',
                          style: TextStyle(
                            color: kGreyLabelColour, 
                            fontSize: kFontSizeBody - 2, 
                            fontWeight: FontWeight.w400
                          ),
                          textAlign: TextAlign.left,
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        ),
      );
    }
    return const SizedBox.shrink();
  }

  /// Group consecutive years into ranges for cleaner display
  List<List<int>> _groupConsecutiveYears(List<int> years) {
    if (years.isEmpty) return [];
    
    final sortedYears = List<int>.from(years)..sort();
    final ranges = <List<int>>[];
    List<int> currentRange = [sortedYears.first];
    
    for (int i = 1; i < sortedYears.length; i++) {
      if (sortedYears[i] == sortedYears[i - 1] + 1) {
        // Consecutive year, add to current range
        currentRange.add(sortedYears[i]);
      } else {
        // Gap found, save current range and start new one
        ranges.add(List<int>.from(currentRange));
        currentRange = [sortedYears[i]];
      }
    }
    
    // Add the last range
    ranges.add(currentRange);
    return ranges;
  }

  void _startListeningToLocationChanges() {
    _positionStreamSubscription = geo.Geolocator.getPositionStream(
      locationSettings: geo.LocationSettings(
        accuracy: geo.LocationAccuracy.low,
        distanceFilter: 500, // meters, adjust as needed
      ),
    ).listen((geo.Position position) async {
      if (_lastPosition == null ||
          _distanceBetween(_lastPosition!, position) > 1000) { // 1km threshold
        _lastPosition = position;
        // Optionally, check if city has changed using placemarkFromCoordinates
        _isDataLoading = true;
        
        // Start progressive loading in the background
        _loadChartDataProgressive();
      }
    });
  }

  double _distanceBetween(geo.Position a, geo.Position b) {
    return geo.Geolocator.distanceBetween(
      a.latitude, a.longitude, b.latitude, b.longitude,
    );
  }

  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    final double chartHeight = 800;

    Widget appContent = Scaffold(
      body: Stack(
        children: [
          // Gradient background fills the whole screen including system areas
          _buildGradientBackground(),
          // Foreground content scrolls above the background
          _buildRefreshIndicator(
            SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: _buildContentPadding(
                context,
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // --- Title/logo row: always visible and scrolls with content ---
                    _buildTitleLogoSection(),
                    // Debug features (only show when debugging)
                    if (AppConfig.shouldShowDebugFeatures) ...[
                      _buildDebugToggleSection(),
                      _buildVersionSection(),
                    ],
                    // --- The rest of the UI, including the FutureBuilder ---
                    _buildFutureBuilder(chartHeight: chartHeight),
                    // Add extra space to ensure content is always scrollable
                    const SizedBox(height: 100),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );

    // Wrap with AnnotatedRegion for mobile platforms
    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
        // iOS uses statusBarBrightness, Android uses statusBarIconBrightness
        statusBarBrightness: Platform.isIOS ? Brightness.dark : null,
        statusBarIconBrightness: Platform.isIOS ? null : Brightness.light,
      ),
      child: appContent,
    );
  }

  /// Simulate endpoint failures for testing purposes
  Future<T> _simulateEndpointFailure<T>(String endpointName, Future<T> Function() apiCall) async {
    if (!SIMULATE_ENDPOINT_FAILURES) {
      return await apiCall();
    }
    
    // Simulate different failure scenarios based on state
    if (endpointName == 'average' && _simulateAverageFailure) {
      debugPrintIfDebugging('Simulating average endpoint failure');
      await Future.delayed(const Duration(seconds: 2)); // Simulate delay
      throw Exception('Simulated average endpoint failure for testing');
    }
    
    if (endpointName == 'trend' && _simulateTrendFailure) {
      debugPrintIfDebugging('Simulating trend endpoint failure');
      await Future.delayed(const Duration(seconds: 2)); // Simulate delay
      throw Exception('Simulated trend endpoint failure for testing');
    }
    
    if (endpointName == 'summary' && _simulateSummaryFailure) {
      debugPrintIfDebugging('Simulating summary endpoint failure');
      await Future.delayed(const Duration(seconds: 2)); // Simulate delay
      throw Exception('Simulated summary endpoint failure for testing');
    }
    
    // If no failure is simulated, proceed with normal call
    return await apiCall();
  }
}

class TemperatureChartData {
  final String year;
  final double temperature;
  final bool isCurrentYear;
  final bool hasData; // Added for gap handling

  TemperatureChartData({
    required this.year,
    required this.temperature,
    required this.isCurrentYear,
    this.hasData = true, // Default to true
  });
}

List<TemperatureChartData> _generateTrendData(List<TemperatureChartData> chartData, double slope) {
  if (chartData.isEmpty) return [];
  
  // Find the middle year to use as reference point (only from years with data)
  final yearsWithData = chartData.where((data) => data.hasData).map((data) => int.parse(data.year)).toList();
  if (yearsWithData.isEmpty) return [];
  
  yearsWithData.sort();
  final middleYear = yearsWithData[yearsWithData.length ~/ 2];
  
  // Calculate the middle temperature (average of all temperatures with data)
  final tempsWithData = chartData.where((data) => data.hasData).map((data) => data.temperature).toList();
  final middleTemp = tempsWithData.reduce((a, b) => a + b) / tempsWithData.length;
  
  // Generate trend line points for all years in chronological order
  final allYears = yearsWithData;
  final minYear = allYears.first;
  final maxYear = allYears.last;
  
  List<TemperatureChartData> trendData = [];
  for (int year = minYear; year <= maxYear; year++) {
    final yearsFromMiddle = year - middleYear;
    final trendTemp = middleTemp + (slope * yearsFromMiddle / 10); // Convert decade slope to yearly
    
    trendData.add(TemperatureChartData(
      year: year.toString(),
      temperature: trendTemp,
      isCurrentYear: year == DateTime.now().year,
      hasData: true,
    ));
  }
  
  return trendData;
}

List<TemperatureChartData> _generateAverageData(List<TemperatureChartData> chartData, double averageTemp) {
  if (chartData.isEmpty) return [];
  
  // Generate average line points for all years in chronological order
  final yearsWithData = chartData.where((data) => data.hasData).map((data) => int.parse(data.year)).toList();
  if (yearsWithData.isEmpty) return [];
  
  yearsWithData.sort();
  final minYear = yearsWithData.first;
  final maxYear = yearsWithData.last;
  
  List<TemperatureChartData> averageData = [];
  for (int year = minYear; year <= maxYear; year++) {
    averageData.add(TemperatureChartData(
      year: year.toString(),
      temperature: averageTemp,
      isCurrentYear: year == DateTime.now().year,
      hasData: true,
    ));
  }
  
  return averageData;
}

String _formatDayMonth(DateTime date) {
  final day = date.day;
  final month = DateFormat('MMMM').format(date);
  String suffix;
  if (day >= 11 && day <= 13) {
    suffix = 'th';
  } else {
    switch (day % 10) {
      case 1:
        suffix = 'st';
        break;
      case 2:
        suffix = 'nd';
        break;
      case 3:
        suffix = 'rd';
        break;
      default:
        suffix = 'th';
    }
  }
  return '$day$suffix $month';
}

Map<String, dynamic> _createResultMap({
  required List<TemperatureChartData> chartData,
  required double? averageTemperature,
  required double? trendSlope,
  required String? summaryText,
  required DateTime dateToUse,
  required String city,
}) {
  return {
    'chartData': chartData,
    'averageTemperature': averageTemperature,
    'trendSlope': trendSlope,
    'summary': summaryText,
    'displayDate': _formatDayMonth(dateToUse),
    'city': city,
  };
}

// Sign up
Future<UserCredential> signUp(String email, String password) async {
  return await FirebaseAuth.instance.createUserWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign in
Future<UserCredential> signIn(String email, String password) async {
  return await FirebaseAuth.instance.signInAnonymously();
}

// Sign out
Future<void> signOut() async {
  await FirebaseAuth.instance.signOut();
}
