import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:geocoding/geocoding.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // This is auto-generated by FlutterFire CLI
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/services.dart';
import 'dart:io' show Platform;
import 'dart:async';

import 'services/temperature_service.dart';

// App color constants
const bool DEBUGGING = false;
const kBackgroundColour = Color(0xFF242456);
const kAccentColour = Color(0xFFFF6B6B);
const kTextPrimaryColour = Color(0xFFECECEC);
const kSummaryColour = Color(0xFF51CF66);
const kAverageColour = Color(0xFF4DABF7);
const kTrendColour = Color(0xFFAAAA00);
const kTrendLineColour = kTrendColour;
const kBarOtherYearColour = kAccentColour;
const kBarCurrentYearColour = kSummaryColour;
const kAxisLabelColour = Color(0xFFECECEC);
const kAxisGridColour = kAxisLabelColour;
const kGreyLabelColour = Color(0xFFB0B0B0);

// Layout constants for easy adjustment
const double kScreenPadding = 8.0;
const double kTitleRowHorizontalMargin = 4.0;
const double kTitleRowIconRightPadding = 6.0;
const double kSectionHorizontalMargin = 4.0;
const double kCitySummaryHorizontalMargin = 4.0;
const double kChartHorizontalMargin = 4.0;
const double kChartInnerPadding = 4.0;
const double kSectionBottomPadding = 22.0;
const double kSectionTopPadding = 22.0;
const double kContentVerticalPadding = 32.0; // Vertical padding for main content area

// Font size constants
const double kFontSizeTitle = 20.0;
const double kFontSizeBody = 14.0;
const double kFontSizeAxisLabel = 12.0;

// Time constants
const int kUseYesterdayHourThreshold = 3; // Use yesterday's data if current hour is before this

/// Clean up and validate location strings for better API compatibility
String _cleanupLocationString(String location) {
  if (location.isEmpty) return 'London, UK';
  
  // Remove extra whitespace and normalize commas
  String cleaned = location.trim();
  
  // Replace multiple spaces with single space
  cleaned = cleaned.replaceAll(RegExp(r'\s+'), ' ');
  
  // Normalize comma spacing (ensure space after comma)
  cleaned = cleaned.replaceAll(RegExp(r',\s*'), ', ');
  
  // Remove trailing comma if present
  cleaned = cleaned.replaceAll(RegExp(r',\s*$'), '');
  
  // Ensure we have at least a city and country
  if (!cleaned.contains(',')) {
    // If no comma, assume it's just a city, add default country
    cleaned = '$cleaned, UK';
  }
  
  return cleaned;
}

/// Detect suspicious or obviously incorrect location strings
bool _isLocationSuspicious(String location) {
  if (location.isEmpty) return true;
  
  final lowerLocation = location.toLowerCase();
  
  // Check for street addresses (which are usually wrong for city-level queries)
  if (lowerLocation.contains('street') || 
      lowerLocation.contains('st,') ||
      lowerLocation.contains('ave,') ||
      lowerLocation.contains('road') ||
      lowerLocation.contains('rd,') ||
      lowerLocation.contains('drive') ||
      lowerLocation.contains('dr,') ||
      lowerLocation.contains('lane') ||
      lowerLocation.contains('ln,') ||
      lowerLocation.contains('blvd') ||
      lowerLocation.contains('boulevard')) {
    return true;
  }
  
  // Check for postal codes (which are usually wrong for city-level queries)
  if (RegExp(r'\d{5}').hasMatch(location) || // US ZIP codes
      RegExp(r'[A-Z]\d[A-Z]\s?\d[A-Z]\d').hasMatch(location)) { // Canadian postal codes
    return true;
  }
  
  // Check for coordinates (which are obviously wrong)
  if (lowerLocation.contains('Â°') || 
      lowerLocation.contains('north') ||
      lowerLocation.contains('south') ||
      lowerLocation.contains('east') ||
      lowerLocation.contains('west')) {
    return true;
  }
  
  // Check for very short or very long location strings
  if (location.length < 3 || location.length > 100) {
    return true;
  }
  
  return false;
}

void debugPrintIfDebugging(Object? message) {
  if (DEBUGGING) {
    // ignore: avoid_print
    print('DEBUG: $message');
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Configure system UI overlay to extend app background over status bar and navigation bar
  _setSystemUIOverlayStyle();
  
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  // Ensure user is signed in (anonymous)
  await _ensureSignedIn();
  runApp(MyApp());
}

void _setSystemUIOverlayStyle() {
  if (kIsWeb) {
    // Web-specific configuration - minimal setup since web doesn't have system UI overlays
    // No need to set SystemUIOverlayStyle on web
    return;
  } else if (Platform.isIOS) {
    // iOS-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarBrightness: Brightness.dark, // Light text on dark background
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else if (Platform.isAndroid) {
    // Android-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light, // Light icons/text
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else {
    // For other platforms, use a default configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
      ),
    );
  }
}

Future<void> _ensureSignedIn() async {
  final auth = FirebaseAuth.instance;
  if (auth.currentUser == null) {
    await auth.signInAnonymously();
  }
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    return MaterialApp(
      title: 'Temperature Trends',
      home: TemperatureScreen(),
    );
  }
}

class TemperatureScreen extends StatefulWidget {
  final Future<Map<String, dynamic>?>? testFuture;
  final AsyncSnapshot<Map<String, dynamic>?>? testSnapshot;

  TemperatureScreen({this.testFuture, this.testSnapshot});

  @override
  _TemperatureScreenState createState() => _TemperatureScreenState();
}

class _TemperatureScreenState extends State<TemperatureScreen> {
  late Future<Map<String, dynamic>?> futureChartData;
  bool _isShowingCachedData = false;
  Timer? _dateCheckTimer;
  DateTime? _lastCheckedDate;

  @override
  void initState() {
    super.initState();
    _loadInitialData();
    _startDateCheckTimer();
  }

  @override
  void dispose() {
    _dateCheckTimer?.cancel();
    super.dispose();
  }

  void _loadInitialData() async {
    debugPrintIfDebugging('_loadInitialData: Starting data load');
    
    // Use test data if provided
    if (widget.testFuture != null) {
      debugPrintIfDebugging('_loadInitialData: Using test data');
      futureChartData = widget.testFuture!;
      return;
    }
    
    // Always start with fresh data loading to avoid blank screens
    setState(() {
      futureChartData = _loadChartData();
      _isShowingCachedData = false;
    });
  }

  Future<Map<String, dynamic>?> _loadChartData() async {
    debugPrintIfDebugging('_loadChartData: Starting chart data load');
    
    try {
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final formattedDate = DateFormat('yyyy-MM-dd').format(dateToUse);
      debugPrintIfDebugging('_loadChartData: Current time: ${now.hour}:${now.minute}, useYesterday: $useYesterday, dateToUse: $formattedDate');

      final service = TemperatureService();
      String city = 'London, UK';
      
      // Try to get user's city via geolocation
      try {
        bool serviceEnabled = await geo.Geolocator.isLocationServiceEnabled();
        if (serviceEnabled) {
          geo.LocationPermission permission = await geo.Geolocator.checkPermission();
          if (permission == geo.LocationPermission.denied) {
            permission = await geo.Geolocator.requestPermission();
          }
          if (permission == geo.LocationPermission.whileInUse || permission == geo.LocationPermission.always) {
            try {
              geo.Position position = await geo.Geolocator.getCurrentPosition(
                desiredAccuracy: geo.LocationAccuracy.low,
              ).timeout(const Duration(seconds: 10));
              
              List<Placemark> placemarks = await placemarkFromCoordinates(
                position.latitude, 
                position.longitude
              ).timeout(const Duration(seconds: 10));
              
              if (placemarks.isNotEmpty) {
                final placemark = placemarks.first;
                if (placemark.locality != null && placemark.locality!.isNotEmpty) {
                  final locality = placemark.locality!;
                  final country = placemark.country;
                  final administrativeArea = placemark.administrativeArea;
                  
                  // Build a more specific location string to avoid ambiguity
                  if (country != null && country.isNotEmpty) {
                    if (administrativeArea != null && administrativeArea.isNotEmpty) {
                      // Use full administrative area name for better global compatibility
                      // This avoids hardcoding specific countries and works worldwide
                      city = '$locality, $administrativeArea, $country';
                    } else {
                      city = '$locality, $country';
                    }
                  } else if (administrativeArea != null && administrativeArea.isNotEmpty) {
                    // Fallback to locality + administrative area if no country
                    city = '$locality, $administrativeArea';
                  } else {
                    city = locality;
                  }
                  
                  debugPrintIfDebugging('Geolocation result - Locality: $locality, Admin: $administrativeArea, Country: $country, Final: $city');
                } else {
                  // If no locality, try to use administrative area + country
                  if (placemark.administrativeArea != null && placemark.administrativeArea!.isNotEmpty) {
                    if (placemark.country != null && placemark.country!.isNotEmpty) {
                      city = '${placemark.administrativeArea}, ${placemark.country}';
                    } else {
                      city = placemark.administrativeArea!;
                    }
                  } else if (placemark.country != null && placemark.country!.isNotEmpty) {
                    city = placemark.country!;
                  }
                }
              }
            } catch (e) {
              debugPrintIfDebugging('Geolocation timeout or error: $e');
            }
          }
        }
      } catch (e) {
        debugPrintIfDebugging('Geolocation failed, falling back to $city: $e');
      }
      
      // Validate and clean up the city string
      city = _cleanupLocationString(city);
      
      // Additional validation to catch obviously wrong locations
      if (_isLocationSuspicious(city)) {
        debugPrintIfDebugging('Suspicious location detected: $city, falling back to default');
        city = 'London, UK';
      }
      
      debugPrintIfDebugging('_loadChartData: Final city: $city');
      final currentYear = dateToUse.year;

      // Try main /data/ endpoint first
      try {
        debugPrintIfDebugging('_loadChartData: Starting /data/ fetch for $city, $formattedDate');
        final tempData = await service
            .fetchCompleteData(city, '$currentYear-${formattedDate.substring(5)}')
            .timeout(const Duration(seconds: 30));
            
        if (tempData.series?.data.isNotEmpty == true) {
          
          List<TemperatureChartData> chartData = [];
          final seriesData = tempData.series!.data;
          
          // Extract year range from the series data
          int minYear = currentYear;
          int maxYear = currentYear;
          if (seriesData.isNotEmpty) {
            minYear = seriesData.map((dp) => dp.x).reduce((a, b) => a < b ? a : b);
            maxYear = seriesData.map((dp) => dp.x).reduce((a, b) => a > b ? a : b);
          }
          
          // Fill in all years in the range, including gaps for missing data
          for (int year = minYear; year <= maxYear; year++) {
            final dataPoint = seriesData.where((dp) => dp.x == year).firstOrNull;
            
            if (dataPoint != null && dataPoint.y != null) {
              // Year has data
              chartData.add(TemperatureChartData(
                year: year.toString(),
                temperature: (dataPoint.y is num) ? (dataPoint.y as num).toDouble() : 0.0,
                isCurrentYear: year == currentYear,
                hasData: true,
              ));
            } else {
              // Year is missing data - add gap
              chartData.add(TemperatureChartData(
                year: year.toString(),
                temperature: 0.0, // Will be ignored in chart rendering
                isCurrentYear: year == currentYear,
                hasData: false,
              ));
            }
          }
          
          final result = _createResultMap(
            chartData: chartData,
            averageTemperature: tempData.average?.temperature,
            trendSlope: tempData.trend?.slope,
            summaryText: tempData.summary,
            dateToUse: dateToUse,
            city: city,
          );
          
          return await _cacheAndReturnResult(result);
        }
      } catch (e) {
        debugPrintIfDebugging('Exception in /data/ fetch: $e');
      }

      // Fallback: use individual endpoints
      try {
        debugPrintIfDebugging('Using fallback endpoints for $city, $formattedDate');
        
        final mmdd = formattedDate.substring(5);
        List<TemperatureChartData> chartData = [];
        double? averageTemperature;
        double? trendSlope;
        String? summaryText;
        int startYear = currentYear - 50;
        int endYear = currentYear;
        
        // Get average data
        try {
          final averageData = await service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: 30));
          averageTemperature = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
          
          if (averageData['year_range'] != null) {
            final yearRange = averageData['year_range'];
            if (yearRange is Map<String, dynamic>) {
              final start = yearRange['start'];
              final end = yearRange['end'];
              if (start is int && end is int) {
                startYear = start;
                endYear = end;
              }
            }
          }
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch average data: $e');
        }
        
        // Get trend data
        try {
          final trendData = await service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: 30));
          final slope = trendData['slope'];
          trendSlope = (slope is num) ? slope.toDouble() : null;
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch trend data: $e');
        }
        
        // Get summary data
        try {
          final summaryData = await service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: 30));
          final summaryRaw = summaryData['summary'];
          summaryText = summaryRaw?.toString();
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch summary data: $e');
        }
        
        // Fetch year-by-year data
        for (int year = startYear; year <= endYear; year++) {
          final dateForYear = '$year-$mmdd';
          try {
            final tempData = await service.fetchTemperature(city, dateForYear);
            chartData.add(TemperatureChartData(
              year: year.toString(),
              temperature: tempData.temperature ?? tempData.average?.temperature ?? 0.0,
              isCurrentYear: year == currentYear,
              hasData: true,
            ));
          } catch (e) {
            debugPrintIfDebugging('Failed to fetch temperature for year $year: $e');
            // Add gap for missing year
            chartData.add(TemperatureChartData(
              year: year.toString(),
              temperature: 0.0, // Will be ignored in chart rendering
              isCurrentYear: year == currentYear,
              hasData: false,
            ));
          }
        }
        
        if (chartData.isNotEmpty) {
          final result = _createResultMap(
            chartData: chartData,
            averageTemperature: averageTemperature,
            trendSlope: trendSlope,
            summaryText: summaryText,
            dateToUse: dateToUse,
            city: city,
          );
          
          return await _cacheAndReturnResult(result);
        }
      } catch (e) {
        debugPrintIfDebugging('Fallback endpoints failed: $e');
      }
      
      // Final fallback: try cached data
      final cached = await _loadCachedChartData();
      if (cached != null) {
        debugPrintIfDebugging('Using cached data as final fallback');
        return cached;
      }
      
      throw Exception('Unable to load temperature data. Please check your internet connection and try again.');
      
    } catch (e) {
      debugPrintIfDebugging('_loadChartData failed: $e');
      rethrow;
    }
  }

  Future<void> _cacheChartData(Map<String, dynamic> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Validate that chartData exists and is a List
      final chartData = data['chartData'];
      if (chartData == null || chartData is! List<TemperatureChartData>) {
        debugPrintIfDebugging('Invalid chartData for caching, skipping cache');
        return;
      }
      
      // Calculate the date that was used for this data (same logic as _loadChartData)
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      
      // Only cache the minimal necessary data
      final cache = jsonEncode({
        'chartData': chartData.map((e) => {
          'year': e.year,
          'temperature': e.temperature,
          'isCurrentYear': e.isCurrentYear,
        }).toList(),
        'averageTemperature': data['averageTemperature'],
        'trendSlope': data['trendSlope'],
        'summary': data['summary'],
        'displayDate': data['displayDate'],
        'city': data['city'],
        'cachedDate': DateFormat('yyyy-MM-dd').format(dateToUse), // Store the date that was actually used for the data
      });
      await prefs.setString('cachedChartData', cache);
    } catch (e) {
      debugPrintIfDebugging('Error caching data: $e');
      // Don't throw, just log the error
    }
  }

  Future<Map<String, dynamic>?> _loadCachedChartData() async {
    final prefs = await SharedPreferences.getInstance();
    final cache = prefs.getString('cachedChartData');
    if (cache == null) return null;
    
    try {
      final decoded = jsonDecode(cache);
      
      // Validate that decoded is a Map
      if (decoded == null || decoded is! Map<String, dynamic>) {
        debugPrintIfDebugging('Cached data is not a valid Map, clearing cache');
        await prefs.remove('cachedChartData');
        return null;
      }
      
      // Check if the date has changed since the data was cached
      final cachedDate = decoded['cachedDate'] as String?;
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold; // Use same logic as _loadChartDataR
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final currentDate = DateFormat('yyyy-MM-dd').format(dateToUse);
      
      if (cachedDate != null && cachedDate != currentDate) {
        // Date has changed, but we'll still use cached data as fallback
        // The fresh data load will be attempted first, and if it fails, we'll fall back to cached
        debugPrintIfDebugging('Date changed from $cachedDate to $currentDate, but keeping cached data as fallback');
        // Don't return null here - let the caller decide whether to use cached data
      }
      
      // Safely extract chartData
      final chartDataRaw = decoded['chartData'];
      if (chartDataRaw == null || chartDataRaw is! List) {
        debugPrintIfDebugging('Cached chartData is invalid, clearing cache');
        await prefs.remove('cachedChartData');
        return null;
      }
      
      final chartDataList = chartDataRaw.map((e) {
        // Validate each chart data item
        if (e == null || e is! Map<String, dynamic>) {
          throw Exception('Invalid chart data item in cache');
        }
        
        return TemperatureChartData(
          year: e['year']?.toString() ?? '',
          temperature: (e['temperature'] is num) ? (e['temperature'] as num).toDouble() : 0.0,
          isCurrentYear: e['isCurrentYear'] == true,
        );
      }).toList();
      
      return {
        'chartData': chartDataList,
        'averageTemperature': decoded['averageTemperature'],
        'trendSlope': decoded['trendSlope'],
        'summary': decoded['summary'],
        'displayDate': decoded['displayDate'],
        'city': decoded['city'],
        'cachedDate': cachedDate, // Include the cached date for reference
      };
    } catch (e) {
      debugPrintIfDebugging('Error loading cached data: $e');
      // Clear corrupted cache
      await prefs.remove('cachedChartData');
      return null;
    }
  }

  Future<Map<String, dynamic>> _cacheAndReturnResult(Map<String, dynamic> result) async {
    await _cacheChartData(result);
    return result;
  }

  Widget _buildRefreshIndicator(Widget child) {
    return RefreshIndicator(
      onRefresh: () async {
        debugPrintIfDebugging('Pull-to-refresh triggered');
        
        // Cancel any existing background refresh to prevent race conditions
        if (_isShowingCachedData) {
          _isShowingCachedData = false;
        }
        
        setState(() {
          futureChartData = _loadChartData();
        });
        
        try {
          await futureChartData;
        } catch (e) {
          debugPrintIfDebugging('Pull-to-refresh failed: $e');
          // Don't rethrow, let the FutureBuilder handle the error
        }
      },
      color: kAccentColour,
      backgroundColor: kBackgroundColour,
      child: child,
    );
  }

  Widget _buildFutureBuilder({required double chartHeight}) {
    return FutureBuilder<Map<String, dynamic>?>(
      future: futureChartData,
      builder: (context, snapshot) {
        final effectiveSnapshot = widget.testSnapshot ?? snapshot;
        
        // Show loading state with spinner and message
        if (effectiveSnapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingSection();
        } 
        
        // Show error state with retry button
        if (effectiveSnapshot.hasError) {
          return _buildRetrySection(
            'Error loading data: ${effectiveSnapshot.error}',
            () {
              debugPrintIfDebugging('Retry button pressed after error');
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        } 
        
        // Show no data state with retry button
        if (!effectiveSnapshot.hasData || effectiveSnapshot.data == null || effectiveSnapshot.data!.isEmpty) {
          return _buildRetrySection(
            'No temperature data available. Please check your internet connection and try again.',
            () {
              debugPrintIfDebugging('Retry button pressed after no data');
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        }

        final data = effectiveSnapshot.data!;
        final chartData = data['chartData'] as List<TemperatureChartData>;
        
        // Show no chart data state with retry button
        if (chartData.isEmpty) {
          return _buildRetrySection(
            'No temperature data available. Please check your internet connection and try again.',
            () {
              debugPrintIfDebugging('Retry button pressed after empty chart data');
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        }
        
        // Validate chart data has valid temperatures
        final validChartData = chartData.where((data) => 
          data.temperature.isFinite && 
          data.temperature.abs() < 100 // Reasonable temperature range
        ).toList();
        
        if (validChartData.isEmpty) {
          return _buildRetrySection(
            'Invalid temperature data received. Please try again.',
            () {
              debugPrintIfDebugging('Retry button pressed after invalid chart data');
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        }
        
        final averageTemperature = data['averageTemperature'] as double?;
        final trendSlope = data['trendSlope'] as double?;
        final summaryText = data['summary'] as String?;
        final displayDate = data['displayDate'] as String?;
        final city = data['city'] as String?;
        
        debugPrintIfDebugging('Average temperature for plot band: $averageTemperatureÂ°C');
        debugPrintIfDebugging('Summary text for UI: $summaryText');
        debugPrintIfDebugging('Summary text is empty: ${summaryText?.isEmpty}');
        debugPrintIfDebugging('Summary text is null: ${summaryText == null}');

        return _buildChartContent(
          chartData: validChartData,
          averageTemperature: averageTemperature,
          trendSlope: trendSlope,
          summaryText: summaryText,
          displayDate: displayDate,
          city: city,
          chartHeight: chartHeight,
          isCachedData: _isShowingCachedData,
          cachedDate: data['cachedDate'] as String?,
        );
      },
    );
  }

  void _startDateCheckTimer() {
    // Check immediately on startup
    _checkDateChange();
    
    // Then check every minute
    _dateCheckTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkDateChange();
    });
  }

  void _checkDateChange() {
    final now = DateTime.now();
    final useYesterday = now.hour < kUseYesterdayHourThreshold;
    final currentDate = useYesterday ? now.subtract(Duration(days: 1)) : now;
    
    if (_lastCheckedDate == null) {
      _lastCheckedDate = currentDate;
      return;
    }
    
    // Check if the date has changed (ignoring time)
    if (_lastCheckedDate!.year != currentDate.year ||
        _lastCheckedDate!.month != currentDate.month ||
        _lastCheckedDate!.day != currentDate.day) {
      debugPrintIfDebugging('Date changed from ${_lastCheckedDate} to $currentDate, reloading data');
      
      // Only reload if we're not already loading fresh data
      if (!_isShowingCachedData) {
        setState(() {
          futureChartData = _loadChartData();
        });
      }
    }
    
    _lastCheckedDate = currentDate;
  }

  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly for this screen
    _setSystemUIOverlayStyle();
    
    final double chartHeight = 800;

    Widget appContent = Scaffold(
      body: Stack(
        children: [
          // Gradient background fills the whole screen including system areas
          _buildGradientBackground(),
          // Foreground content scrolls above the background
          _buildRefreshIndicator(
            SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: _buildContentPadding(
                context,
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // --- Title/logo row: always visible and scrolls with content ---
                    _buildTitleLogoSection(),
                    // --- The rest of the UI, including the FutureBuilder ---
                    _buildFutureBuilder(chartHeight: chartHeight),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );

    // Only wrap with AnnotatedRegion on mobile platforms
    if (kIsWeb) {
      return appContent;
    } else {
      return AnnotatedRegion<SystemUiOverlayStyle>(
        value: Platform.isIOS
          ? const SystemUiOverlayStyle(
              statusBarColor: Colors.transparent,
              statusBarBrightness: Brightness.dark,
              systemNavigationBarColor: Colors.transparent,
              systemNavigationBarIconBrightness: Brightness.light,
            )
          : const SystemUiOverlayStyle(
              statusBarColor: Colors.transparent,
              statusBarIconBrightness: Brightness.light,
              systemNavigationBarColor: Colors.transparent,
              systemNavigationBarIconBrightness: Brightness.light,
            ),
        child: appContent,
      );
    }
  }
}

class TemperatureChartData {
  final String year;
  final double temperature;
  final bool isCurrentYear;
  final bool hasData; // Added for gap handling

  TemperatureChartData({
    required this.year,
    required this.temperature,
    required this.isCurrentYear,
    this.hasData = true, // Default to true
  });
}

List<TemperatureChartData> _generateTrendData(List<TemperatureChartData> chartData, double slope) {
  if (chartData.isEmpty) return [];
  
  // Find the middle year to use as reference point
  final years = chartData.map((data) => int.parse(data.year)).toList();
  years.sort();
  final middleYear = years[years.length ~/ 2];
  
  // Calculate the middle temperature (average of all temperatures)
  final middleTemp = chartData.map((data) => data.temperature).reduce((a, b) => a + b) / chartData.length;
  
  // Generate trend line points using only the actual years from chart data
  return chartData.map((data) {
    final year = int.parse(data.year);
    final yearsFromMiddle = year - middleYear;
    final trendTemp = middleTemp + (slope * yearsFromMiddle / 10); // Convert decade slope to yearly
    
    return TemperatureChartData(
      year: data.year,
      temperature: trendTemp,
      isCurrentYear: data.isCurrentYear,
      hasData: data.hasData,
    );
  }).toList();
}

List<TemperatureChartData> _generateAverageData(List<TemperatureChartData> chartData, double averageTemp) {
  if (chartData.isEmpty) return [];
  
  // Generate average line points using only the actual years from chart data
  return chartData.map((data) {
    return TemperatureChartData(
      year: data.year,
      temperature: averageTemp,
      isCurrentYear: data.isCurrentYear,
      hasData: data.hasData,
    );
  }).toList();
}

String _formatDayMonth(DateTime date) {
  final day = date.day;
  final month = DateFormat('MMMM').format(date);
  String suffix;
  if (day >= 11 && day <= 13) {
    suffix = 'th';
  } else {
    switch (day % 10) {
      case 1:
        suffix = 'st';
        break;
      case 2:
        suffix = 'nd';
        break;
      case 3:
        suffix = 'rd';
        break;
      default:
        suffix = 'th';
    }
  }
  return '$day$suffix $month';
}

Map<String, dynamic> _createResultMap({
  required List<TemperatureChartData> chartData,
  required double? averageTemperature,
  required double? trendSlope,
  required String? summaryText,
  required DateTime dateToUse,
  required String city,
}) {
  return {
    'chartData': chartData,
    'averageTemperature': averageTemperature,
    'trendSlope': trendSlope,
    'summary': summaryText,
    'displayDate': _formatDayMonth(dateToUse),
    'city': city,
  };
}

  Widget _buildRetryButton(VoidCallback onPressed) {
    return ElevatedButton(
      onPressed: onPressed,
      child: const Text(
        'Retry',
        style: TextStyle(color: kTextPrimaryColour),
      ),
      style: ElevatedButton.styleFrom(
        backgroundColor: kAccentColour,
      ),
    );
  }

  Widget _buildRetrySection(String message, VoidCallback onRetry) {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Center(
          child: Container(
            width: contentWidth,
            margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  message,
                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody),
                  textAlign: TextAlign.left,
                ),
                const SizedBox(height: 16),
                _buildRetryButton(onRetry),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildLoadingSection() {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Center(
          child: Container(
            width: contentWidth,
            margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const CircularProgressIndicator(color: kAccentColour),
                const SizedBox(height: 16),
                Text(
                  'Loading temperature data...',
                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 8),
                Text(
                  'This may take a few moments',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildGradientBackground() {
    return SizedBox.expand(
      child: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Color(0xFF242456), // Top color
              Color(0xFF343499), // Bottom color
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTitleLogoSection() {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        debugPrintIfDebugging('Title area - Screen width: ${constraints.maxWidth}, contentWidth: $contentWidth, horizontalOffset: $horizontalOffset, isWideScreen: ${constraints.maxWidth >= 600}');
        
        return Padding(
          padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
          child: Stack(
            children: [
              // Logo positioned to the left of content area
              if (horizontalOffset > 0)
                Positioned(
                  left: horizontalOffset - 60, // Position logo 60px to the left of content (50px + 10px for bar alignment)
                  child: SvgPicture.asset(
                    'assets/logo.svg',
                    width: 40,
                    height: 40,
                  ),
                ),
              // Title text aligned with content left edge
              Align(
                alignment: Alignment.centerLeft,
                child: Container(
                  margin: EdgeInsets.only(
                    left: horizontalOffset > 0 ? horizontalOffset : kTitleRowHorizontalMargin,
                  ),
                  child: Row(
                    children: [
                      // Only show logo inline on narrow screens
                      if (horizontalOffset <= 0)
                        Padding(
                          padding: const EdgeInsets.only(right: kTitleRowIconRightPadding),
                          child: SvgPicture.asset(
                            'assets/logo.svg',
                            width: 40,
                            height: 40,
                          ),
                        ),
                      Text(
                        'TempHist',
                        style: TextStyle(
                          color: kAccentColour,
                          fontSize: kFontSizeTitle,
                          fontWeight: FontWeight.bold,
                          letterSpacing: 1.2,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildContentPadding(BuildContext context, Widget child) {
    return Padding(
      padding: EdgeInsets.only(
        top: MediaQuery.of(context).padding.top + kContentVerticalPadding,
        bottom: MediaQuery.of(context).padding.bottom + kContentVerticalPadding,
        left: kScreenPadding,
        right: kScreenPadding,
      ),
      child: child,
    );
  }

  Widget _buildChartContent({
    required List<TemperatureChartData> chartData,
    required double? averageTemperature,
    required double? trendSlope,
    required String? summaryText,
    required String? displayDate,
    required String? city,
    required double chartHeight,
    bool isCachedData = false,
    String? cachedDate,
  }) {
    // Calculate minimum and maximum temperature for Y-axis (only from years with data)
    final validData = chartData.where((data) => data.hasData).toList();
    double yAxisMin;
    double yAxisMax;
    
    if (validData.isEmpty) {
      // Fallback if no valid data
      yAxisMin = -10.0;
      yAxisMax = 40.0;
    } else {
      final minTemp = validData.map((data) => data.temperature).reduce((a, b) => a < b ? a : b);
      final maxTemp = validData.map((data) => data.temperature).reduce((a, b) => a > b ? a : b);
      yAxisMin = (minTemp - 2).floorToDouble(); // Start 2 degrees below minimum
      yAxisMax = (maxTemp + 2).ceilToDouble(); // End 2 degrees above maximum
    }
    
    debugPrintIfDebugging('_buildChartContent: summaryText = "$summaryText"');
    debugPrintIfDebugging('_buildChartContent: summaryText?.isNotEmpty = ${summaryText?.isNotEmpty}');
    debugPrintIfDebugging('_buildChartContent: kSummaryColour = $kSummaryColour');
    
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(kChartInnerPadding),
        child: LayoutBuilder(
          builder: (context, constraints) {
            double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
            debugPrintIfDebugging('Main content - Screen width: ${constraints.maxWidth}, contentWidth: $contentWidth, isWideScreen: ${constraints.maxWidth >= 600}');
            return Center(
              child: Container(
                width: contentWidth,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Date and location above summary
                    if (displayDate != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kSectionHorizontalMargin),
                            child: Text(
                              isCachedData && cachedDate != null 
                                ? _formatDayMonth(DateFormat('yyyy-MM-dd').parse(cachedDate))
                                : displayDate,
                              style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    if (city != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Text(
                                  city,
                                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                  textAlign: TextAlign.left,
                                ),
                                if (isCachedData)
                                  Padding(
                                    padding: const EdgeInsets.only(left: 8.0),
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 6.0, vertical: 2.0),
                                      decoration: BoxDecoration(
                                        color: kGreyLabelColour.withOpacity(0.2),
                                        borderRadius: BorderRadius.circular(4.0),
                                      ),
                                      child: Text(
                                        'cached',
                                        style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                                        textAlign: TextAlign.left,
                                      ),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    if (summaryText?.isNotEmpty == true)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              summaryText!,
                              style: TextStyle(color: kSummaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    SizedBox(
                      height: chartHeight,
                      child: SfCartesianChart(
                        margin: EdgeInsets.symmetric(horizontal: kChartHorizontalMargin),
                        tooltipBehavior: TooltipBehavior(
                          enable: true,
                          format: 'point.x: point.y',
                          canShowMarker: false,
                          header: '',
                          textStyle: TextStyle(fontSize: kFontSizeBody),
                        ),
                        series: [
                          BarSeries<TemperatureChartData, int>(
                            dataSource: chartData.where((data) => data.hasData).toList(),
                            xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                            yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                            pointColorMapper: (TemperatureChartData data, int index) =>
                                data.isCurrentYear ? kBarCurrentYearColour : kBarOtherYearColour,
                            width: 0.8, // Restored to proper thickness
                            name: 'Yearly Temperature',
                            enableTooltip: true,
                            // Ensure consistent spacing and prevent edge cropping
                            spacing: 0.1, // Reduced spacing to maintain bar thickness
                            borderRadius: BorderRadius.circular(2),
                          ),
                          if (averageTemperature != null)
                            LineSeries<TemperatureChartData, int>(
                              dataSource: _generateAverageData(chartData.where((data) => data.hasData).toList(), averageTemperature!),
                              xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                              yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                              color: kAverageColour,
                              width: 2,
                              name: 'Average Temperature',
                              markerSettings: MarkerSettings(isVisible: false),
                            ),
                          if (trendSlope != null)
                            LineSeries<TemperatureChartData, int>(
                              dataSource: _generateTrendData(chartData.where((data) => data.hasData).toList(), trendSlope!),
                              xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                              yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                              color: kTrendColour,
                              width: 2,
                              name: 'Trend',
                              markerSettings: MarkerSettings(isVisible: false),
                            ),
                        ],
                        primaryXAxis: NumericAxis(
                          labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                          majorGridLines: MajorGridLines(width: 0),
                          labelIntersectAction: AxisLabelIntersectAction.hide,
                          // Add margins to prevent cropping of first and last bars
                          minimum: chartData.map((data) => int.parse(data.year)).reduce((a, b) => a < b ? a : b).toDouble(),
                          maximum: chartData.map((data) => int.parse(data.year)).reduce((a, b) => a > b ? a : b).toDouble(),
                          interval: 1, // Show every year
                          labelFormat: '{value}',
                          // Ensure proper spacing and prevent cropping
                          plotOffset: 20,
                        ),
                        primaryYAxis: NumericAxis(
                          labelFormat: '{value}Â°C',
                          numberFormat: NumberFormat('0'),
                          minimum: yAxisMin,
                          maximum: yAxisMax,
                          majorGridLines: MajorGridLines(width: 0),
                          labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                        ),
                        plotAreaBorderWidth: 0,
                        enableAxisAnimation: true,
                        // Ensure proper spacing for bars
                      ),
                    ),
                    // Average temperature text below chart
                    if (averageTemperature != null)
                      Padding(
                        padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              'Average: ${averageTemperature.toStringAsFixed(1)}Â°C',
                              style: TextStyle(color: kAverageColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    // Trend text below chart
                    if (trendSlope != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              trendSlope > 0 
                                ? 'Trend: Rising at ${trendSlope.abs().toStringAsFixed(1)}Â°C/decade'
                                : 'Trend: Falling at ${trendSlope.abs().toStringAsFixed(1)}Â°C/decade',
                              style: TextStyle(color: kTrendColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    // Data completeness indicator
                    _buildDataCompletenessIndicator(chartData),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildDataCompletenessIndicator(List<TemperatureChartData> chartData) {
    final missingYears = chartData.where((data) => !data.hasData).map((data) => int.parse(data.year)).toList();
    final hasGaps = missingYears.isNotEmpty;
    
    if (hasGaps) {
      // Sort missing years for better display
      missingYears.sort();
      
      // Group consecutive missing years for cleaner display
      final missingRanges = _groupConsecutiveYears(missingYears);
      
      String missingText;
      if (missingRanges.length == 1 && missingRanges.first.length == 1) {
        // Single year missing
        missingText = 'Year ${missingRanges.first.first} is missing';
      } else if (missingRanges.length == 1) {
        // Consecutive years missing
        missingText = 'Years ${missingRanges.first.first}-${missingRanges.first.last} are missing';
      } else {
        // Multiple ranges missing
        final ranges = missingRanges.map((range) {
          if (range.length == 1) return range.first.toString();
          return '${range.first}-${range.last}';
        }).join(', ');
        missingText = 'Years $ranges are missing';
      }
      
      return Padding(
        padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
        child: Align(
          alignment: Alignment.centerLeft,
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Note: $missingText. This may affect the accuracy of the trend and average lines.',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                  textAlign: TextAlign.left,
                ),
                const SizedBox(height: 4),
                Text(
                  'Data completeness: ${((chartData.where((data) => data.hasData).length / chartData.length) * 100).toStringAsFixed(0)}%',
                  style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                  textAlign: TextAlign.left,
                ),
              ],
            ),
          ),
        ),
      );
    }
    return const SizedBox.shrink();
  }

  /// Group consecutive years into ranges for cleaner display
  List<List<int>> _groupConsecutiveYears(List<int> years) {
    if (years.isEmpty) return [];
    
    final sortedYears = List<int>.from(years)..sort();
    final ranges = <List<int>>[];
    List<int> currentRange = [sortedYears.first];
    
    for (int i = 1; i < sortedYears.length; i++) {
      if (sortedYears[i] == sortedYears[i - 1] + 1) {
        // Consecutive year, add to current range
        currentRange.add(sortedYears[i]);
      } else {
        // Gap found, save current range and start new one
        ranges.add(List<int>.from(currentRange));
        currentRange = [sortedYears[i]];
      }
    }
    
    // Add the last range
    ranges.add(currentRange);
    return ranges;
  }

    // Sign up
Future<UserCredential> signUp(String email, String password) async {
  return await FirebaseAuth.instance.createUserWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign in
Future<UserCredential> signIn(String email, String password) async {
  return await FirebaseAuth.instance.signInWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign out
Future<void> signOut() async {
  await FirebaseAuth.instance.signOut();
}
