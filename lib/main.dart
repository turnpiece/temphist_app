import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:geocoding/geocoding.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // This is auto-generated by FlutterFire CLI
import 'package:firebase_auth/firebase_auth.dart';

import 'package:flutter/services.dart';
import 'dart:io' show Platform;
import 'dart:async'; // Added for StreamSubscription and StreamController
import 'dart:convert'; // Added for jsonEncode/jsonDecode

import 'services/temperature_service.dart';
import 'config/app_config.dart';
import 'utils/debug_utils.dart';

// App color constants
// Note: These are no longer constants because they depend on runtime configuration
// but they maintain the same interface for backward compatibility
const kBackgroundColour = Color(0xFF242456);
const kAccentColour = Color(0xFFFF6B6B);
const kTextPrimaryColour = Color(0xFFECECEC);
const kSummaryColour = Color(0xFF51CF66);
const kAverageColour = Color(0xFF4DABF7);
const kTrendColour = Color(0xFFAAAA00);
const kTrendLineColour = kTrendColour;
const kBarOtherYearColour = kAccentColour;
const kBarCurrentYearColour = kSummaryColour;
const kAxisLabelColour = Color(0xFFECECEC);
const kAxisGridColour = kAxisLabelColour;
const kGreyLabelColour = Color(0xFFB0B0B0);

// Layout constants for easy adjustment
// These constants control the spacing and padding throughout the app's UI

// Base padding from screen edges - affects all content
const double kScreenPadding = 12.0;

// Title/logo section spacing
const double kTitleRowIconRightPadding = 6.0; // Space between logo and title text
const double kTitleRowBottomPadding = 16.0; // Space below each section

// Main content area margins
const double kContentHorizontalMargin = 8.0; // Additional horizontal margin for content
const double kContentVerticalPadding = 32.0; // Vertical padding for main content area (top and bottom)

// Chart-specific spacing
const double kChartHorizontalMargin = 0.0; // Horizontal margins around the chart
const double kChartInnerPadding = 0.0; // Inner padding within the chart area
const double kChartRightMargin = 20.0; // Extra right margin for Y-axis labels

// Section spacing - controls gaps between UI sections (date, location, summary, chart, etc.)
const double kSectionBottomPadding = 22.0; // Space below each section
const double kSectionTopPadding = 22.0; // Space above each section

// App constants
const String kAppTitle = 'TempHist'; // Application title

// Font size constants - control text sizing throughout the app
const double kFontSizeTitle = 26.0; // Main title text (e.g., "TempHist")
const double kFontSizeBody = 17.0; // Body text (date, location, summary, etc.)
const double kFontSizeAxisLabel = 16.0; // Chart axis labels (years and temperatures)
const double kIconSize = 17.0; // Standard icon size for UI elements

// Time constants
const int kUseYesterdayHourThreshold = 3; // Use yesterday's data if current hour is before this (3 AM)
const int kAverageTrendDisplayDelaySeconds = 35; // Delay before showing average/trend lines (seconds)
const int kApiTimeoutSeconds = 35; // API timeout (must be longer than display timer to prevent race conditions)

// Default location constant
const String kDefaultLocation = 'London, UK';

/// Helper function to get current date and location for API calls
/// Returns a map with 'date', 'mmdd', and 'city' keys
Map<String, String> _getCurrentDateAndLocation(String determinedLocation) {
  final now = DateTime.now();
  final useYesterday = now.hour < kUseYesterdayHourThreshold;
  final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
  final mmdd = DateFormat('MM-dd').format(dateToUse);
  final city = determinedLocation.isNotEmpty ? determinedLocation : kDefaultLocation;
  
  return {
    'date': DateFormat('yyyy-MM-dd').format(dateToUse),
    'mmdd': mmdd,
    'city': city,
  };
}

/// Clean up and validate location strings for better API compatibility
String _cleanupLocationString(String location) {
  if (location.isEmpty) return kDefaultLocation;
  
  // Remove extra whitespace and normalize commas
  String cleaned = location.trim();
  
  // Replace multiple spaces with single space
  cleaned = cleaned.replaceAll(RegExp(r'\s+'), ' ');
  
  // Normalize comma spacing (ensure space after comma)
  cleaned = cleaned.replaceAll(RegExp(r',\s*'), ', ');
  
  // Remove trailing comma if present
  cleaned = cleaned.replaceAll(RegExp(r',\s*$'), '');
  
  // Ensure we have at least a city and country
  if (!cleaned.contains(',')) {
    // If no comma, assume it's just a city, add default country
    cleaned = '$cleaned, UK';
  }
  
  return cleaned;
}

/// Detect suspicious or obviously incorrect location strings
/// This is very conservative since location data comes from device GPS/geocoding
bool _isLocationSuspicious(String location) {
  if (location.isEmpty) return true;
  
  // Check for very short or very long location strings (indicates API issues)
  if (location.length < 2 || location.length > 200) {
    return true;
  }
  
  // Check for pure numeric strings (postal codes without city names)
  if (RegExp(r'^\d+$').hasMatch(location.trim())) {
    return true;
  }
  
  return false;
}

/// Legacy function for backward compatibility.
/// @deprecated Use DebugUtils.logLazy() directly for better performance and consistency.
void debugPrintIfDebugging(Object? message) {
  DebugUtils.logLazy(() => message);
}



void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Configure system UI overlay to extend app background over status bar and navigation bar
  _setSystemUIOverlayStyle();
  
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  // Ensure user is signed in (anonymous)
  await _ensureSignedIn();
  runApp(TempHist());
}

void _setSystemUIOverlayStyle() {
  if (Platform.isIOS) {
    // iOS-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarBrightness: Brightness.dark, // Light text on dark background
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else if (Platform.isAndroid) {
    // Android-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light, // Light icons/text
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else {
    // For other platforms, use a default configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
      ),
    );
  }
}

Future<void> _ensureSignedIn() async {
  final auth = FirebaseAuth.instance;
  if (auth.currentUser == null) {
    await auth.signInAnonymously();
  }
}

class TempHist extends StatelessWidget {
  const TempHist({super.key});

  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: kAppTitle,
      home: TemperatureScreen(),
      // Add a custom loading screen theme
      theme: ThemeData(
        scaffoldBackgroundColor: kBackgroundColour,
        // This helps prevent the white flash during initialization
        colorScheme: ColorScheme.fromSeed(
          seedColor: kAccentColour,
          brightness: Brightness.dark,
        ),
      ),
    );
  }
}

class TemperatureScreen extends StatefulWidget {
  final Future<Map<String, dynamic>?>? testFuture;
  final AsyncSnapshot<Map<String, dynamic>?>? testSnapshot;

  const TemperatureScreen({super.key, this.testFuture, this.testSnapshot});

  @override
  TemperatureScreenState createState() => TemperatureScreenState();
}

class SplashScreen extends StatelessWidget {
  const SplashScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Color(0xFF242456), // Top color
              Color(0xFF343499), // Bottom color
            ],
          ),
        ),
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Logo
              SvgPicture.asset(
                'assets/logo.svg',
                width: 80,
                height: 80,
              ),
              const SizedBox(height: 24),
              // App title
              Text(
                kAppTitle,
                style: TextStyle(
                  color: kAccentColour,
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  letterSpacing: 1.2,
                ),
              ),
              const SizedBox(height: 16),
              // Loading indicator
              const CircularProgressIndicator(
                color: kAccentColour,
                strokeWidth: 3,
              ),
              const SizedBox(height: 16),
              // Loading text
              Text(
                'Loading...',
                style: TextStyle(
                  color: kTextPrimaryColour,
                  fontSize: kFontSizeBody,
                  fontWeight: FontWeight.w400,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class TemperatureScreenState extends State<TemperatureScreen> with WidgetsBindingObserver {
  Future<Map<String, dynamic>?>? futureChartData;
  Timer? _loadingMessageTimer;
  int _loadingElapsedSeconds = 0;
  String _currentLoadingMessage = '';
  String _determinedLocation = ''; // Full location for API
  String _displayLocation = ''; // Short location for display
  bool _isLocationDetermined = false;
  DateTime? _locationDeterminedAt; // Timestamp when location was last determined
  DateTime? _currentDataDate; // The date for which data is currently loaded
  bool _isDataLoading = false;
  Timer? _averageTrendDisplayTimer;
  
  // Track app initialization state
  bool _isAppInitialized = false;
  bool _splashScreenMinTimeElapsed = false;
  Timer? _splashScreenTimer;
  
  
  // Add error tracking for different data types
  bool _averageDataFailed = false;
  bool _trendDataFailed = false;
  bool _summaryDataFailed = false;
  bool _chartDataHasGaps = false;
  
  // Rate limit tracking
  bool _averageDataRateLimited = false;
  bool _trendDataRateLimited = false;
  bool _summaryDataRateLimited = false;
  bool _chartDataRateLimited = false; // Track if chart data fetching is rate limited
  
  // Add automatic retry timer
  Timer? _autoRetryTimer;
  
  // Store current data for updates
  Map<String, dynamic>? _currentData;
  
  // Track retry loading states
  bool _isRetryingAverage = false;
  bool _isRetryingTrend = false;
  bool _isRetryingSummary = false;
  
  // Simulation state for testing
  bool _simulateAverageFailure = AppConfig.defaultSimulateAverageFailure;
  bool _simulateTrendFailure = AppConfig.defaultSimulateTrendFailure;
  bool _simulateSummaryFailure = AppConfig.defaultSimulateSummaryFailure;

  geo.Position? _lastPosition;
  StreamSubscription<geo.Position>? _positionStreamSubscription;

  // Track chart data retry attempts
  bool _isRetryingChartData = false;
  int _chartDataRetryCount = 0;
  static const int _maxChartDataRetries = 3;
  
  // Track if progressive loading has completed to prevent flash of "no data" message
  bool _progressiveLoadingCompleted = false;
  
  // Track current loading operation to prevent race conditions
  bool _isLoadingOperationActive = false;
  
  // Track chart data loading failures
  bool _chartDataFailed = false;
  bool _chartDataFailedDueToRateLimit = false;
  final List<int> _failedYears = []; // Track which years failed to load

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    
    // Debug mode detection logging
    debugPrintIfDebugging('🔧 Debug mode detection:');
    debugPrintIfDebugging('  - kDebugMode: $kDebugMode');
    debugPrintIfDebugging('  - AppConfig.isDebugMode: ${AppConfig.isDebugMode}');
    debugPrintIfDebugging('  - AppConfig.enableDebugUI: ${AppConfig.enableDebugUI}');
    debugPrintIfDebugging('  - AppConfig.shouldShowDebugFeatures: ${AppConfig.shouldShowDebugFeatures}');
    
    // Start minimum splash screen timer
    _startSplashScreenTimer();
    
    // If we have a test future, skip all the async initialization
    if (widget.testFuture != null) {
      futureChartData = widget.testFuture;
      return;
    }
    
    // Initialize with location determination first, then load data
    _initializeApp();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _positionStreamSubscription?.cancel();
    _stopAverageTrendDisplayTimer();
    _splashScreenTimer?.cancel();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    
    if (state == AppLifecycleState.resumed) {
      debugPrintIfDebugging('App resumed - checking if location or date needs refresh');
      _checkAndRefreshLocationIfNeeded();
      _checkAndRefreshDataIfDateChanged();
    }
  }

  Future<void> _initializeApp() async {
    // If we have a test future, use it directly
    if (widget.testFuture != null) {
      futureChartData = widget.testFuture;
      setState(() {
        _isAppInitialized = true;
      });
      return;
    }
    
    // Verbose logging for initialization steps
    DebugUtils.verboseLazy(() => 'Initializing app - test future: ${widget.testFuture != null}');
    
    // Clean up expired cache entries
    await _cleanupExpiredCache();
    
    // First determine location
    await _determineLocation();
    
    // Mark app as initialized after location is determined
    // But only if minimum splash screen time has elapsed
    if (_splashScreenMinTimeElapsed) {
      setState(() {
        _isAppInitialized = true;
      });
    } else {
      // If splash screen time hasn't elapsed, wait for it
      _waitForSplashScreenAndInitialize();
    }
    
    // Then start loading temperature data progressively
    _isDataLoading = true;
    _progressiveLoadingCompleted = false;
    
    // Start the loading message timer after location is determined
    _startLoadingMessageTimer();
    
    // Start the average/trend display timer
    _startAverageTrendDisplayTimer();
    
    // Start progressive loading in the background
    _loadChartDataProgressive();
    
    // Start listening to location changes after initial setup is complete
    _startListeningToLocationChanges();
    
    DebugUtils.verboseLazy(() => 'App initialization completed - location: $_determinedLocation, loading: $_isDataLoading');
  }

  Future<void> _checkAndRefreshLocationIfNeeded() async {
    // If no location has been determined yet, don't refresh
    if (!_isLocationDetermined || _locationDeterminedAt == null) {
      return;
    }
    
    final now = DateTime.now();
    final timeSinceLastLocation = now.difference(_locationDeterminedAt!);
    
    // Refresh location if it's been more than 1 hour
    if (timeSinceLastLocation.inHours >= 1) {
      debugPrintIfDebugging('Location is ${timeSinceLastLocation.inHours} hours old, refreshing...');
      await _refreshLocationAndData();
    } else {
      debugPrintIfDebugging('Location is only ${timeSinceLastLocation.inMinutes} minutes old, keeping cached location');
    }
  }

  Future<void> _checkAndRefreshDataIfDateChanged() async {
    // If no data has been loaded yet, don't check
    if (_currentDataDate == null) {
      return;
    }
    
    final currentDateInfo = _getCurrentDateAndLocation(_determinedLocation);
    final currentDate = DateTime.parse(currentDateInfo['date']!);
    
    // Check if the date has changed
    if (!_isSameDate(_currentDataDate!, currentDate)) {
      debugPrintIfDebugging('Date changed from ${_formatDayMonth(_currentDataDate!)} to ${_formatDayMonth(currentDate)}, refreshing data...');
      await _refreshDataForNewDate();
    } else {
      debugPrintIfDebugging('Date unchanged (${_formatDayMonth(currentDate)}), keeping current data');
    }
  }

  bool _isSameDate(DateTime date1, DateTime date2) {
    return date1.year == date2.year && 
           date1.month == date2.month && 
           date1.day == date2.day;
  }

  Future<void> _refreshDataForNewDate() async {
    debugPrintIfDebugging('Refreshing data for new date...');
    
    // Update the current data date
    final currentDateInfo = _getCurrentDateAndLocation(_determinedLocation);
    _currentDataDate = DateTime.parse(currentDateInfo['date']!);
    
    // Reload data with new date using progressive loading
    _isDataLoading = true;
    _progressiveLoadingCompleted = false;
    
    // Start the average/trend display timer
    _startAverageTrendDisplayTimer();
    
    // Start progressive loading in the background
    _loadChartDataProgressive();
    
    // Restart loading message timer
    _startLoadingMessageTimer();
  }

  Future<void> _refreshLocationAndData() async {
    debugPrintIfDebugging('Refreshing location and data...');
    
    // Reset location state
    setState(() {
      _isLocationDetermined = false;
      _determinedLocation = '';
      _displayLocation = '';
      _locationDeterminedAt = null;
    });
    
    // Determine new location
    await _determineLocation();
    
    // Reload data with new location using progressive loading
    _isDataLoading = true;
    _progressiveLoadingCompleted = false;
    
    // Start the average/trend display timer
    _startAverageTrendDisplayTimer();
    
    // Start progressive loading in the background
    _loadChartDataProgressive();
    
    // Restart loading message timer
    _startLoadingMessageTimer();
  }

  void _startAutoRetryTimer() {
    // Cancel any existing timer
    _autoRetryTimer?.cancel();
    
    // Start a new timer that will retry after 10 seconds
    // But only retry endpoints that aren't rate limited
    _autoRetryTimer = Timer(const Duration(seconds: 10), () {
      if (mounted) {
        final shouldRetryAverage = _averageDataFailed && !_averageDataRateLimited;
        final shouldRetryTrend = _trendDataFailed && !_trendDataRateLimited;
        final shouldRetrySummary = _summaryDataFailed && !_summaryDataRateLimited;
        
        if (shouldRetryAverage || shouldRetryTrend || shouldRetrySummary) {
          _retryFailedData();
        }
      }
    });
  }

  void _stopAutoRetryTimer() {
    _autoRetryTimer?.cancel();
    _autoRetryTimer = null;
  }

  void _startAverageTrendDisplayTimer() {
    // Cancel any existing timer
    _averageTrendDisplayTimer?.cancel();
    
    // Start a timer that will show average/trend lines after the configured delay
    _averageTrendDisplayTimer = Timer(const Duration(seconds: kAverageTrendDisplayDelaySeconds), () {
      debugPrintIfDebugging('Average/trend display timer triggered - showing lines after timeout');
      setState(() {
        // Force show average and trend lines by setting _isDataLoading to false
        _isDataLoading = false;
      });
    });
  }

  void _stopAverageTrendDisplayTimer() {
    _averageTrendDisplayTimer?.cancel();
    _averageTrendDisplayTimer = null;
  }


  void _resetErrorStates() {
    setState(() {
      _averageDataFailed = false;
      _trendDataFailed = false;
      _summaryDataFailed = false;
      _chartDataHasGaps = false;
      _isRetryingAverage = false;
      _isRetryingTrend = false;
      _isRetryingSummary = false;
      _isRetryingChartData = false;
      _chartDataRetryCount = 0;
      
      // Reset rate limit flags
      _averageDataRateLimited = false;
      _trendDataRateLimited = false;
      _summaryDataRateLimited = false;
      _chartDataRateLimited = false;
      
      // Reset chart data failure tracking
      _chartDataFailed = false;
      _chartDataFailedDueToRateLimit = false;
      _failedYears.clear();
    });
  }

  // Cache expiration constants
  static const Duration _locationCacheExpiration = Duration(minutes: 30);
  static const Duration _currentDateCacheExpiration = Duration(hours: 1);
  static const Duration _historicalDataCacheExpiration = Duration(hours: 24);
  static const Duration _summaryCacheExpiration = Duration(hours: 1);
  static const Duration _averageTrendCacheExpiration = Duration(hours: 6);

  Future<void> _clearCache() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('cachedChartData');
      debugPrintIfDebugging('Cache cleared for simulation mode');
    } catch (e) {
      debugPrintIfDebugging('Error clearing cache: $e');
    }
  }

  /// Clear only location cache (for testing different locations)
  Future<void> _clearLocationCache() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('cachedLocation');
      debugPrintIfDebugging('Location cache cleared');
    } catch (e) {
      debugPrintIfDebugging('Error clearing location cache: $e');
    }
  }

  /// Cache location data with timestamp
  Future<void> _cacheLocation(String location, String displayLocation) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cacheData = {
        'location': location,
        'displayLocation': displayLocation,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      };
      await prefs.setString('cachedLocation', jsonEncode(cacheData));
      debugPrintIfDebugging('📍 Location cached: $location');
    } catch (e) {
      debugPrintIfDebugging('Error caching location: $e');
    }
  }

  /// Load cached location if still valid
  Future<Map<String, String>?> _loadCachedLocation() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cachedData = prefs.getString('cachedLocation');
      if (cachedData == null) return null;

      final data = jsonDecode(cachedData) as Map<String, dynamic>;
      final timestamp = DateTime.fromMillisecondsSinceEpoch(data['timestamp'] as int);
      final age = DateTime.now().difference(timestamp);

      if (age > _locationCacheExpiration) {
        debugPrintIfDebugging('📍 Cached location expired (${age.inMinutes} minutes old)');
        await prefs.remove('cachedLocation');
        return null;
      }

      debugPrintIfDebugging('📍 Using cached location: ${data['location']} (${age.inMinutes} minutes old)');
      return {
        'location': data['location'] as String,
        'displayLocation': data['displayLocation'] as String,
      };
    } catch (e) {
      debugPrintIfDebugging('Error loading cached location: $e');
      return null;
    }
  }

  /// Cache temperature data for a specific year and location
  Future<void> _cacheTemperatureData(int year, String location, String date, Map<String, dynamic> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cacheKey = 'tempData_${location}_${year}_$date';
      final cacheData = {
        'data': data,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
        'year': year,
        'location': location,
        'date': date,
      };
      await prefs.setString(cacheKey, jsonEncode(cacheData));
      debugPrintIfDebugging('🌡️ Temperature data cached: $year for $location');
    } catch (e) {
      debugPrintIfDebugging('Error caching temperature data: $e');
    }
  }

  /// Load cached temperature data if still valid
  Future<Map<String, dynamic>?> _loadCachedTemperatureData(int year, String location, String date) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cacheKey = 'tempData_${location}_${year}_$date';
      final cachedData = prefs.getString(cacheKey);
      if (cachedData == null) return null;

      final data = jsonDecode(cachedData) as Map<String, dynamic>;
      final timestamp = DateTime.fromMillisecondsSinceEpoch(data['timestamp'] as int);
      final age = DateTime.now().difference(timestamp);

      // Determine expiration based on whether it's current year or historical
      final isCurrentYear = year == DateTime.now().year;
      final expiration = isCurrentYear ? _currentDateCacheExpiration : _historicalDataCacheExpiration;

      if (age > expiration) {
        debugPrintIfDebugging('🌡️ Cached temperature data expired: $year (${age.inHours} hours old)');
        await prefs.remove(cacheKey);
        return null;
      }

      debugPrintIfDebugging('🌡️ Using cached temperature data: $year (${age.inMinutes} minutes old)');
      return data['data'] as Map<String, dynamic>;
    } catch (e) {
      debugPrintIfDebugging('Error loading cached temperature data: $e');
      return null;
    }
  }

  /// Cache API response data (average, trend, summary)
  Future<void> _cacheApiResponse(String endpoint, String location, String date, Map<String, dynamic> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cacheKey = 'api_${endpoint}_${location}_$date';
      final cacheData = {
        'data': data,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
        'endpoint': endpoint,
        'location': location,
        'date': date,
      };
      await prefs.setString(cacheKey, jsonEncode(cacheData));
      debugPrintIfDebugging('📊 API response cached: $endpoint for $location');
    } catch (e) {
      debugPrintIfDebugging('Error caching API response: $e');
    }
  }

  /// Load cached API response if still valid
  Future<Map<String, dynamic>?> _loadCachedApiResponse(String endpoint, String location, String date) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final cacheKey = 'api_${endpoint}_${location}_$date';
      final cachedData = prefs.getString(cacheKey);
      if (cachedData == null) return null;

      final data = jsonDecode(cachedData) as Map<String, dynamic>;
      final timestamp = DateTime.fromMillisecondsSinceEpoch(data['timestamp'] as int);
      final age = DateTime.now().difference(timestamp);

      // Determine expiration based on endpoint type
      Duration expiration;
      switch (endpoint) {
        case 'summary':
          expiration = _summaryCacheExpiration;
          break;
        case 'average':
        case 'trend':
          expiration = _averageTrendCacheExpiration;
          break;
        default:
          expiration = Duration(hours: 1); // Default to 1 hour
      }

      if (age > expiration) {
        debugPrintIfDebugging('📊 Cached API response expired: $endpoint (${age.inHours} hours old)');
        await prefs.remove(cacheKey);
        return null;
      }

      debugPrintIfDebugging('📊 Using cached API response: $endpoint (${age.inMinutes} minutes old)');
      return data['data'] as Map<String, dynamic>;
    } catch (e) {
      debugPrintIfDebugging('Error loading cached API response: $e');
      return null;
    }
  }

  /// Clean up expired cache entries
  Future<void> _cleanupExpiredCache() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final keys = prefs.getKeys();
      final now = DateTime.now();
      int cleanedCount = 0;

      for (final key in keys) {
        if (key.startsWith('tempData_') || key.startsWith('api_')) {
          try {
            final cachedData = prefs.getString(key);
            if (cachedData != null) {
              final data = jsonDecode(cachedData) as Map<String, dynamic>;
              final timestamp = DateTime.fromMillisecondsSinceEpoch(data['timestamp'] as int);
              final age = now.difference(timestamp);
              
              Duration expiration;
              if (key.startsWith('tempData_')) {
                // Temperature data cache
                final year = data['year'] as int;
                final isCurrentYear = year == now.year;
                expiration = isCurrentYear ? _currentDateCacheExpiration : _historicalDataCacheExpiration;
              } else if (key.startsWith('api_')) {
                // API response cache
                final endpoint = data['endpoint'] as String;
                switch (endpoint) {
                  case 'summary':
                    expiration = _summaryCacheExpiration;
                    break;
                  case 'average':
                  case 'trend':
                    expiration = _averageTrendCacheExpiration;
                    break;
                  default:
                    expiration = Duration(hours: 1);
                }
              } else {
                continue; // Skip unknown cache types
              }

              if (age > expiration) {
                await prefs.remove(key);
                cleanedCount++;
              }
            }
          } catch (e) {
            // If we can't parse the data, remove it
            await prefs.remove(key);
            cleanedCount++;
          }
        }
      }

      if (cleanedCount > 0) {
        debugPrintIfDebugging('🧹 Cleaned up $cleanedCount expired cache entries');
      }
    } catch (e) {
      debugPrintIfDebugging('Error cleaning up cache: $e');
    }
  }


  Future<void> _retryFailedData() async {
    if (!_averageDataFailed && !_trendDataFailed && !_summaryDataFailed) {
      return; // Nothing to retry
    }
    
    debugPrintIfDebugging('Retrying failed data fetches...');
    
    try {
      final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
      final mmdd = dateInfo['mmdd']!;
      final city = dateInfo['city']!;
      
      final service = TemperatureService();
      
      // Retry average data if it failed
      if (_averageDataFailed) {
        setState(() {
          _isRetryingAverage = true;
        });
        
        try {
          final averageData = await _simulateEndpointFailure('average', () => 
            service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds))
          );
          final newAverage = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
          
          if (newAverage != null) {
            setState(() {
              _averageDataFailed = false;
              _isRetryingAverage = false;
            });
            // Update the current data with new average
            _rebuildDataWithNewAverage(newAverage);
            // Stop auto-retry timer if no more failures
            if (!_trendDataFailed && !_summaryDataFailed) {
              _stopAutoRetryTimer();
            }
          } else {
            setState(() {
              _isRetryingAverage = false;
            });
          }
        } catch (e) {
          debugPrintIfDebugging('Retry of average data failed: $e');
          
          // Check if it's a rate limit error - don't retry these
          if (e is RateLimitException) {
            setState(() {
              _isRetryingAverage = false;
              _averageDataFailed = true;
              _averageDataRateLimited = true; // New flag for rate limiting
            });
            // Stop auto-retry timer for rate limit errors
            _stopAutoRetryTimer();
          } else {
            setState(() {
              _isRetryingAverage = false;
            });
          }
        }
      }
      
      // Retry trend data if it failed
      if (_trendDataFailed) {
        setState(() {
          _isRetryingTrend = true;
        });
        
        try {
          final trendData = await _simulateEndpointFailure('trend', () => 
            service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds))
          );
          final newSlope = trendData['slope'];
          if (newSlope != null) {
            setState(() {
              _trendDataFailed = false;
              _isRetryingTrend = false;
            });
            // Update the current data with new trend
            _rebuildDataWithNewTrend((newSlope as num).toDouble());
            // Stop auto-retry timer if no more failures
            if (!_averageDataFailed && !_summaryDataFailed) {
              _stopAutoRetryTimer();
            }
          } else {
            setState(() {
              _isRetryingTrend = false;
            });
          }
        } catch (e) {
          debugPrintIfDebugging('Retry of trend data failed: $e');
          setState(() {
            _isRetryingTrend = false;
          });
        }
      }
      
      // Retry summary data if it failed
      if (_summaryDataFailed) {
        setState(() {
          _isRetryingSummary = true;
        });
        
        try {
          final summaryData = await service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds));
          final newSummary = summaryData['summary']?.toString();
          if (newSummary != null && newSummary.isNotEmpty) {
            setState(() {
              _summaryDataFailed = false;
              _isRetryingSummary = false;
            });
            // Update the current data with new summary
            _rebuildDataWithNewSummary(newSummary);
            // Stop auto-retry timer if no more failures
            if (!_averageDataFailed && !_trendDataFailed) {
              _stopAutoRetryTimer();
            }
          } else {
            setState(() {
              _isRetryingSummary = false;
            });
          }
        } catch (e) {
          debugPrintIfDebugging('Retry of summary data failed: $e');
          setState(() {
            _isRetryingSummary = false;
          });
        }
      }
    } catch (e) {
      debugPrintIfDebugging('Error during retry: $e');
    }
  }

  Future<void> _retryAverageData() async {
    if (!_averageDataFailed) return;
    
    debugPrintIfDebugging('Retrying average data...');
    
    try {
      final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
      final mmdd = dateInfo['mmdd']!;
      final city = dateInfo['city']!;
      
      final service = TemperatureService();
      
      setState(() {
        _isRetryingAverage = true;
      });
      
      try {
        final averageData = await _simulateEndpointFailure('average', () => 
          service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds))
        );
        final newAverage = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
        
        if (newAverage != null) {
          setState(() {
            _averageDataFailed = false;
            _isRetryingAverage = false;
          });
          _rebuildDataWithNewAverage(newAverage);
          // Stop auto-retry timer if no more failures
          if (!_trendDataFailed && !_summaryDataFailed) {
            _stopAutoRetryTimer();
          }
        } else {
          setState(() {
            _isRetryingAverage = false;
          });
        }
      } catch (e) {
        debugPrintIfDebugging('Retry of average data failed: $e');
        setState(() {
          _isRetryingAverage = false;
        });
      }
    } catch (e) {
      debugPrintIfDebugging('Error during average retry: $e');
      setState(() {
        _isRetryingAverage = false;
      });
    }
  }

  Future<void> _retryTrendData() async {
    if (!_trendDataFailed) return;
    
    debugPrintIfDebugging('Retrying trend data...');
    
    try {
      final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
      final mmdd = dateInfo['mmdd']!;
      final city = dateInfo['city']!;
      
      final service = TemperatureService();
      
      setState(() {
        _isRetryingTrend = true;
      });
      
      try {
        final trendData = await service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds));
        final newSlope = trendData['slope'];
        if (newSlope != null) {
          setState(() {
            _trendDataFailed = false;
            _isRetryingTrend = false;
          });
          _rebuildDataWithNewTrend((newSlope as num).toDouble());
          // Stop auto-retry timer if no more failures
          if (!_averageDataFailed && !_summaryDataFailed) {
            _stopAutoRetryTimer();
          }
        } else {
          setState(() {
            _isRetryingTrend = false;
          });
        }
      } catch (e) {
        debugPrintIfDebugging('Retry of trend data failed: $e');
        setState(() {
          _isRetryingTrend = false;
        });
      }
    } catch (e) {
      debugPrintIfDebugging('Error during trend retry: $e');
      setState(() {
        _isRetryingTrend = false;
      });
    }
  }

  Future<void> _retrySummaryData() async {
    if (!_summaryDataFailed) return;
    
    debugPrintIfDebugging('Retrying summary data...');
    
    try {
      final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
      final mmdd = dateInfo['mmdd']!;
      final city = dateInfo['city']!;
      
      final service = TemperatureService();
      
      setState(() {
        _isRetryingSummary = true;
      });
      
      try {
        final summaryData = await service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds));
        final newSummary = summaryData['summary']?.toString();
        if (newSummary != null && newSummary.isNotEmpty) {
          setState(() {
            _summaryDataFailed = false;
            _isRetryingSummary = false;
          });
          _rebuildDataWithNewSummary(newSummary);
          // Stop auto-retry timer if no more failures
          if (!_averageDataFailed && !_trendDataFailed) {
            _stopAutoRetryTimer();
          }
        } else {
          setState(() {
            _isRetryingSummary = false;
          });
        }
      } catch (e) {
        debugPrintIfDebugging('Retry of summary data failed: $e');
        setState(() {
          _isRetryingSummary = false;
        });
      }
    } catch (e) {
      debugPrintIfDebugging('Error during summary retry: $e');
      setState(() {
        _isRetryingSummary = false;
      });
    }
  }

  Future<void> _retryChartData() async {
    if (_chartDataRetryCount >= _maxChartDataRetries) {
      debugPrintIfDebugging('🛑 Max chart data retries reached ($_chartDataRetryCount/$_maxChartDataRetries), not retrying further');
      return;
    }
    
    debugPrintIfDebugging('🔄 Retrying chart data... (attempt ${_chartDataRetryCount + 1}/$_maxChartDataRetries)');
    debugPrintIfDebugging('📋 Failed years to retry: $_failedYears');
    
    // Store the failed years before clearing them
    final yearsToRetry = List<int>.from(_failedYears);
    
    setState(() {
      _isRetryingChartData = true;
      _chartDataFailed = false;
      _chartDataFailedDueToRateLimit = false;
      _failedYears.clear();
    });
    
    try {
      // Increment retry count
      _chartDataRetryCount++;
      
      // Retry loading the failed years specifically
      if (yearsToRetry.isNotEmpty) {
        debugPrintIfDebugging('🎯 Retrying specific failed years: $yearsToRetry');
        // Temporarily restore the failed years for the retry function
        _failedYears.addAll(yearsToRetry);
        await _retryFailedYears();
      } else {
        debugPrintIfDebugging('🔄 No specific failed years, triggering full refresh');
        // If no specific failed years, trigger a full refresh
        await _handleRefresh();
      }
      
      setState(() {
        _isRetryingChartData = false;
      });
      debugPrintIfDebugging('✅ Chart data retry completed');
    } catch (e) {
      debugPrintIfDebugging('❌ Error during chart data retry: $e');
      setState(() {
        _isRetryingChartData = false;
      });
    }
  }

  // if years didn't load before try loading them again
  Future<void> _retryFailedYears() async {
    if (_failedYears.isEmpty) {
      debugPrintIfDebugging('⚠️ No failed years to retry');
      return;
    }
    
    debugPrintIfDebugging('🔄 Retrying failed years: $_failedYears');
    
    try {
      final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
      final mmdd = dateInfo['mmdd']!;
      final city = dateInfo['city']!;
      
      debugPrintIfDebugging('📍 Retry parameters - city: $city, date: $mmdd');
      
      final service = TemperatureService();
      final currentData = _currentData;
      if (currentData == null) {
        debugPrintIfDebugging('❌ No current data available for retry');
        return;
      }
      
      List<TemperatureChartData> chartData = List<TemperatureChartData>.from(currentData['chartData']);
      int successCount = 0;
      
      // Retry each failed year
      for (int year in _failedYears) {
        final dateForYear = '$year-$mmdd';
        debugPrintIfDebugging('🔄 Retrying year $year ($dateForYear)');
        try {
          final tempData = await service.fetchTemperature(city, dateForYear);
          final temperature = tempData.temperature ?? tempData.average?.temperature;
          
          if (temperature != null) {
            // Find and update the entry for this year
            final yearIndex = chartData.indexWhere((data) => data.year == year.toString());
            if (yearIndex != -1) {
              chartData[yearIndex] = TemperatureChartData(
                year: year.toString(),
                temperature: temperature,
                isCurrentYear: year == DateTime.now().year,
                hasData: true,
              );
              
              successCount++;
              debugPrintIfDebugging('✅ Successfully retried year $year: ${temperature.toStringAsFixed(1)}°C');
            }
          } else {
            debugPrintIfDebugging('❌ No valid temperature data for retry year $year');
          }
        } catch (e) {
          debugPrintIfDebugging('❌ Failed to retry year $year: $e');
          if (e is RateLimitException) {
            debugPrintIfDebugging('⚠️ Rate limit hit during retry, stopping');
            setState(() {
              _chartDataFailedDueToRateLimit = true;
            });
            break;
          }
        }
        
        // Add a small delay between retries
        await Future.delayed(const Duration(milliseconds: 200));
      }
      
      // Update the current data with retried results
      _currentData!['chartData'] = chartData;
      
      debugPrintIfDebugging('📊 Retry completed: $successCount/${_failedYears.length} years successfully retried');
      
      if (mounted) {
        setState(() {});
      }
      
    } catch (e) {
      debugPrintIfDebugging('❌ Error during failed years retry: $e');
    }
  }

  void _rebuildDataWithNewAverage(double newAverage) {
    if (_currentData != null) {
      setState(() {
        _currentData!['averageTemperature'] = newAverage;
      });
    }
  }

  void _rebuildDataWithNewTrend(double newSlope) {
    if (_currentData != null) {
      setState(() {
        _currentData!['trendSlope'] = newSlope;
      });
    }
  }

  void _rebuildDataWithNewSummary(String newSummary) {
    if (_currentData != null) {
      setState(() {
        _currentData!['summary'] = newSummary;
      });
    }
  }


  Future<void> _determineLocation() async {
    try {
      String city = kDefaultLocation;
      
      // Try to load cached location first
      final cachedLocation = await _loadCachedLocation();
      if (cachedLocation != null) {
        debugPrintIfDebugging('Using cached location: ${cachedLocation['location']}');
        setState(() {
          _determinedLocation = cachedLocation['location']!;
          _displayLocation = cachedLocation['displayLocation']!;
          _isLocationDetermined = true;
          _locationDeterminedAt = DateTime.now();
        });
        return;
      }
      
      // Try to get user's city via geolocation
      try {
        debugPrintIfDebugging('_determineLocation: Starting geolocation');
        
        bool serviceEnabled = await geo.Geolocator.isLocationServiceEnabled();
        if (serviceEnabled) {
          geo.LocationPermission permission = await geo.Geolocator.checkPermission();
          if (permission == geo.LocationPermission.denied) {
            permission = await geo.Geolocator.requestPermission();
          }
          if (permission == geo.LocationPermission.whileInUse || permission == geo.LocationPermission.always) {
            try {
              geo.Position position = await geo.Geolocator.getCurrentPosition(
                locationSettings: const geo.LocationSettings(
                  accuracy: geo.LocationAccuracy.low,
                ),
              ).timeout(const Duration(seconds: 10));
              
              debugPrintIfDebugging('_determineLocation: Position obtained - lat: ${position.latitude}, lon: ${position.longitude}');
              
              List<Placemark> placemarks = await placemarkFromCoordinates(
                position.latitude, 
                position.longitude
              ).timeout(const Duration(seconds: 10));
              
              if (placemarks.isNotEmpty) {
                final placemark = placemarks.first;
                if (placemark.locality != null && placemark.locality!.isNotEmpty) {
                  final locality = placemark.locality!;
                  final country = placemark.country;
                  final administrativeArea = placemark.administrativeArea;
                  
                  // Build a more specific location string to avoid ambiguity
                  if (country != null && country.isNotEmpty) {
                    if (administrativeArea != null && administrativeArea.isNotEmpty) {
                      city = '$locality, $administrativeArea, $country';
                    } else {
                      city = '$locality, $country';
                    }
                  } else if (administrativeArea != null && administrativeArea.isNotEmpty) {
                    city = '$locality, $administrativeArea';
                  } else {
                    city = locality;
                  }
                  
                  debugPrintIfDebugging('Geolocation result - Locality: $locality, Admin: $administrativeArea, Country: $country, Final: $city');
                } else {
                  // If no locality, try to use administrative area + country
                  if (placemark.administrativeArea != null && placemark.administrativeArea!.isNotEmpty) {
                    if (placemark.country != null && placemark.country!.isNotEmpty) {
                      city = '${placemark.administrativeArea}, ${placemark.country}';
                    } else {
                      city = placemark.administrativeArea!;
                    }
                  } else if (placemark.country != null && placemark.country!.isNotEmpty) {
                    city = placemark.country!;
                  }
                }
              }
            } catch (e) {
              debugPrintIfDebugging('Geolocation timeout or error: $e');
            }
          }
        }
      } catch (e) {
        debugPrintIfDebugging('Geolocation failed, falling back to $city: $e');
      }
      
      // Validate and clean up the city string
      city = _cleanupLocationString(city);
      
      // Additional validation to catch obviously wrong locations
      if (_isLocationSuspicious(city)) {
        debugPrintIfDebugging('Suspicious location detected: $city, falling back to default');
        city = kDefaultLocation;
      }
      
      debugPrintIfDebugging('_determineLocation: Final city: $city');
      
      // Verbose logging for location determination
      DebugUtils.verboseWithContextLazy('Location', () => 'Determined location: $city (display: ${_extractDisplayLocation(city)})');
      
      // Update the UI with the determined location
      setState(() {
        _determinedLocation = city; // Full location for API
        _displayLocation = _extractDisplayLocation(city); // Short location for display
        _isLocationDetermined = true;
        _locationDeterminedAt = DateTime.now(); // Record when location was determined
      });
      
      // Cache the location
      await _cacheLocation(city, _extractDisplayLocation(city));
      
      // Reset loading message timer to start temperature-related messages
      _loadingElapsedSeconds = 0;
      _updateLoadingMessage();
      
    } catch (e) {
      debugPrintIfDebugging('_determineLocation failed: $e');
      // Set default location if everything fails
      setState(() {
        _determinedLocation = kDefaultLocation;
        _displayLocation = _extractDisplayLocation(kDefaultLocation);
        _isLocationDetermined = true;
        _locationDeterminedAt = DateTime.now(); // Record when location was determined
      });
      
      // Reset loading message timer to start temperature-related messages
      _loadingElapsedSeconds = 0;
      _updateLoadingMessage();
    }
  }

  void _startSplashScreenTimer() {
    // Skip splash screen timer in test mode
    if (widget.testFuture != null) {
      _splashScreenMinTimeElapsed = true;
      return;
    }
    
    // Show splash screen for minimum 2 seconds to prevent white flash
    _splashScreenTimer = Timer(const Duration(seconds: 2), () {
      if (mounted) {
        setState(() {
          _splashScreenMinTimeElapsed = true;
        });
        // If app is already initialized, we can proceed
        if (_isAppInitialized) {
          // App is ready, no additional action needed
        }
      }
    });
  }

  void _waitForSplashScreenAndInitialize() {
    // Skip in test mode
    if (widget.testFuture != null) {
      setState(() {
        _isAppInitialized = true;
      });
      return;
    }
    
    // Wait for splash screen timer to complete, then initialize
    Timer.periodic(const Duration(milliseconds: 100), (timer) {
      if (_splashScreenMinTimeElapsed && mounted) {
        timer.cancel();
        setState(() {
          _isAppInitialized = true;
        });
      }
    });
  }

  void _startLoadingMessageTimer() {
    _loadingElapsedSeconds = 0;
    _updateLoadingMessage();
    
    _loadingMessageTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      _loadingElapsedSeconds++;
      _updateLoadingMessage();
    });
  }

  void _stopLoadingMessageTimer() {
    _loadingMessageTimer?.cancel();
    _loadingMessageTimer = null;
  }


  String _extractDisplayLocation(String fullLocation) {
    if (fullLocation.isEmpty) return '';
    
    // Split by comma and take the first part (city)
    final parts = fullLocation.split(',');
    if (parts.isNotEmpty) {
      return parts.first.trim();
    }
    
    return fullLocation;
  }


  void _updateLoadingMessage() {
    if (!mounted) return;
    
    String newMessage;
    
    // Only show temperature-related messages if location has been determined
    if (!_isLocationDetermined) {
      if (_loadingElapsedSeconds < 5) {
        newMessage = 'Determining your location...';
      } else if (_loadingElapsedSeconds < 15) {
        newMessage = 'Getting your location from GPS...';
      } else if (_loadingElapsedSeconds < 30) {
        newMessage = 'Still determining your location...';
      } else {
        newMessage = 'Location detection is taking longer than expected.';
      }
    } else {
      // Location is determined, show temperature-related messages
      if (_loadingElapsedSeconds < 10) {
        newMessage = 'Loading temperature data...';
      } else if (_loadingElapsedSeconds < 25) {
        // Calculate the date that will be used (same logic as _loadChartData)
        final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
        final dateToUse = DateTime.parse(dateInfo['date']!);
        final friendlyDate = _formatDayMonth(dateToUse);
        newMessage = 'Getting temperatures on $friendlyDate over the past 50 years.';
      } else if (_loadingElapsedSeconds < 45) {
        // Use the display location if available
        final locationText = _displayLocation.isNotEmpty ? _displayLocation : 'your area';
        newMessage = 'Is today warmer than average in $locationText?';
      } else if (_loadingElapsedSeconds < 60) {
        newMessage = 'Once we have the data we\'ll know.';
      } else if (_loadingElapsedSeconds < 80) {
        newMessage = 'Please be patient. It shouldn\'t be much longer.';
      } else {
        newMessage = 'The server is taking a while to respond.';
      }
    }
    
    if (newMessage != _currentLoadingMessage) {
      setState(() {
        _currentLoadingMessage = newMessage;
      });
    }
  }

  Future<void> _loadChartDataProgressive() async {
    // Prevent multiple concurrent loading operations
    if (_isLoadingOperationActive) {
      debugPrintIfDebugging('_loadChartDataProgressive: Already loading, skipping duplicate request');
      return;
    }
    
    _isLoadingOperationActive = true;
    debugPrintIfDebugging('_loadChartDataProgressive: Starting progressive chart data load');
    
    try {
      final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
      final formattedDate = dateInfo['date']!;
      final dateToUse = DateTime.parse(formattedDate);
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      debugPrintIfDebugging('_loadChartDataProgressive: Current time: ${now.hour}:${now.minute}, useYesterday: $useYesterday, dateToUse: $formattedDate');

      final service = TemperatureService();
      String city = dateInfo['city']!;
      
      // Update the current data date
      _currentDataDate = dateToUse;
      
      debugPrintIfDebugging('_loadChartDataProgressive: Using determined city: $city');
      final currentYear = dateToUse.year;

      // Skip main /data/ endpoint for progressive loading to ensure year-by-year loading is visible
      // This forces the fallback method which loads data progressively
      debugPrintIfDebugging('_loadChartDataProgressive: Skipping main endpoint to force progressive loading');

      // Fallback: use individual endpoints with progressive loading
      debugPrintIfDebugging('Using fallback endpoints for $city, $formattedDate');
      
      final mmdd = formattedDate.substring(5);
      double? averageTemperature;
      double? trendSlope;
      String? summaryText;
      int startYear = currentYear - 50;
      int endYear = currentYear;
      
      // Get average data first
      try {
        // Try to load from cache first
        final cachedAverage = await _loadCachedApiResponse('average', city, mmdd);
        Map<String, dynamic> averageData;
        
        if (cachedAverage != null) {
          debugPrintIfDebugging('📊 Using cached average data');
          // Add a small delay to make progressive loading visible even with cached data
          await Future.delayed(const Duration(milliseconds: 100));
          averageData = cachedAverage;
        } else {
          debugPrintIfDebugging('📊 Fetching fresh average data');
          averageData = await _simulateEndpointFailure('average', () => 
            service.fetchAverageData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds))
          );
          // Cache the successful response
          await _cacheApiResponse('average', city, mmdd, averageData);
        }
        
        averageTemperature = averageData['average'] != null ? (averageData['average'] as num).toDouble() : null;
        
        if (averageData['year_range'] != null) {
          final yearRange = averageData['year_range'];
          if (yearRange is Map<String, dynamic>) {
            final start = yearRange['start'];
            final end = yearRange['end'];
            if (start is int && end is int) {
              startYear = start;
              endYear = end;
            }
          }
        }
      } catch (e) {
        debugPrintIfDebugging('Failed to fetch average data: $e');
        setState(() {
          _averageDataFailed = true;
          if (e is RateLimitException) {
            _averageDataRateLimited = true;
          }
        });
      }
      
      // Get trend data
      try {
        // Try to load from cache first
        final cachedTrend = await _loadCachedApiResponse('trend', city, mmdd);
        Map<String, dynamic> trendData;
        
        if (cachedTrend != null) {
          debugPrintIfDebugging('📊 Using cached trend data');
          // Add a small delay to make progressive loading visible even with cached data
          await Future.delayed(const Duration(milliseconds: 100));
          trendData = cachedTrend;
        } else {
          debugPrintIfDebugging('📊 Fetching fresh trend data');
          trendData = await _simulateEndpointFailure('trend', () => 
            service.fetchTrendData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds))
          );
          // Cache the successful response
          await _cacheApiResponse('trend', city, mmdd, trendData);
        }
        
        final slope = trendData['slope'];
        trendSlope = (slope is num) ? slope.toDouble() : null;
      } catch (e) {
        debugPrintIfDebugging('Failed to fetch trend data: $e');
        setState(() {
          _trendDataFailed = true;
          if (e is RateLimitException) {
            _trendDataRateLimited = true;
          }
        });
      }
      
      // Get summary data
      try {
        // Try to load from cache first
        final cachedSummary = await _loadCachedApiResponse('summary', city, mmdd);
        Map<String, dynamic> summaryData;
        
        if (cachedSummary != null) {
          debugPrintIfDebugging('📊 Using cached summary data');
          // Add a small delay to make progressive loading visible even with cached data
          await Future.delayed(const Duration(milliseconds: 100));
          summaryData = cachedSummary;
        } else {
          debugPrintIfDebugging('📊 Fetching fresh summary data');
          summaryData = await _simulateEndpointFailure('summary', () => 
            service.fetchSummaryData(city, mmdd).timeout(const Duration(seconds: kApiTimeoutSeconds))
          );
          // Cache the successful response
          await _cacheApiResponse('summary', city, mmdd, summaryData);
        }
        
        final summaryRaw = summaryData['summary'];
        summaryText = summaryRaw?.toString();
      } catch (e) {
        debugPrintIfDebugging('Failed to fetch summary data: $e');
        setState(() {
          _summaryDataFailed = true;
          if (e is RateLimitException) {
            _summaryDataRateLimited = true;
          }
        });
      }
      
      // Calculate final year range
      final finalStartYear = startYear < 1975 ? 1975 : startYear;
      final finalEndYear = endYear > currentYear ? currentYear : endYear;
      
      // Create chart data with placeholder entries for all years in the range
      List<TemperatureChartData> chartData = [];
      for (int year = finalStartYear; year <= finalEndYear; year++) {
        chartData.add(TemperatureChartData(
          year: year.toString(),
          temperature: 0.0, // Placeholder value
          isCurrentYear: year == currentYear,
          hasData: false, // Will be set to true when data is loaded
        ));
      }
      
      // Set initial result with placeholder chart data
      final initialResult = _createResultMap(
        chartData: chartData,
        averageTemperature: averageTemperature,
        trendSlope: trendSlope,
        summaryText: summaryText,
        dateToUse: dateToUse,
        city: city,
      );
      _currentData = initialResult;
      
      // Update the UI to show the chart structure
      if (mounted) {
        setState(() {});
      }
      
      // Load from most recent to oldest (2025 -> 1975) to create right-to-left filling effect
      debugPrintIfDebugging('Starting chart data loading for years $finalEndYear to $finalStartYear');
      int consecutiveFailures = 0;
      const int maxConsecutiveFailures = 5; // Stop after 5 consecutive failures
      int totalAttempts = 0;
      int successfulAttempts = 0;
      
      for (int year = finalEndYear; year >= finalStartYear; year--) {
        totalAttempts++;
        
        // Check if we've hit a rate limit - stop making more requests
        if (_chartDataRateLimited) {
          debugPrintIfDebugging('Rate limit detected, stopping chart data loading at year $year (attempted $totalAttempts years, $successfulAttempts successful)');
          break;
        }
        
        // Check for too many consecutive failures - might indicate API is down
        if (consecutiveFailures >= maxConsecutiveFailures) {
          debugPrintIfDebugging('Too many consecutive failures ($consecutiveFailures), stopping at year $year (attempted $totalAttempts years, $successfulAttempts successful)');
          setState(() {
            _chartDataFailed = true;
          });
          break;
        }
        
        final dateForYear = '$year-$mmdd';
        debugPrintIfDebugging('🔄 About to fetch temperature data for year $year ($dateForYear) - attempt $totalAttempts');
        
        // Try to load from cache first
        final cachedData = await _loadCachedTemperatureData(year, city, dateForYear);
        if (cachedData != null) {
          debugPrintIfDebugging('📦 Using cached data for year $year');
          // Add a small delay to make progressive loading visible even with cached data
          await Future.delayed(const Duration(milliseconds: 50));
          // Process cached data the same way as fresh data
          final temperature = cachedData['temperature'] ?? cachedData['average']?['temperature'];
          if (temperature != null) {
            final yearIndex = chartData.indexWhere((data) => data.year == year.toString());
            if (yearIndex != -1) {
              chartData[yearIndex] = TemperatureChartData(
                year: year.toString(),
                temperature: temperature,
                isCurrentYear: year == currentYear,
                hasData: true,
              );
              
              _currentData!['chartData'] = chartData;
              if (mounted) {
                setState(() {});
              }
              
              successfulAttempts++;
              consecutiveFailures = 0;
              debugPrintIfDebugging('✓ Successfully loaded cached data for year $year: ${temperature.toStringAsFixed(1)}°C');
            }
            continue; // Skip API call since we have cached data
          }
        }
        
        try {
          // Add a timeout to individual API calls to prevent hanging
          final tempData = await service.fetchTemperature(city, dateForYear)
              .timeout(const Duration(seconds: 30), onTimeout: () {
            debugPrintIfDebugging('⚠️ API request for year $year timed out after 30 seconds');
            throw TimeoutException('API request for year $year timed out', const Duration(seconds: 30));
          });
          debugPrintIfDebugging('✅ API response received for year $year');
          
          // Check if we have valid temperature data
          final temperature = tempData.temperature ?? tempData.average?.temperature;
          
          if (temperature != null) {
            // Find the existing entry for this year and update it
            final yearIndex = chartData.indexWhere((data) => data.year == year.toString());
            if (yearIndex != -1) {
              chartData[yearIndex] = TemperatureChartData(
                year: year.toString(),
                temperature: temperature,
                isCurrentYear: year == currentYear,
                hasData: true,
              );
              
              // Update the current data and trigger a rebuild
              _currentData!['chartData'] = chartData;
              
              // Trigger a UI update to show the new bar
              if (mounted) {
                setState(() {});
              }
              
              // Cache the successful data
              final dataToCache = {
                'temperature': temperature,
                'year': year,
                'date': dateForYear,
              };
              await _cacheTemperatureData(year, city, dateForYear, dataToCache);
              
              successfulAttempts++;
              consecutiveFailures = 0; // Reset failure counter on success
              debugPrintIfDebugging('✓ Successfully loaded data for year $year: ${temperature.toStringAsFixed(1)}°C (successful: $successfulAttempts/$totalAttempts)');
            }
          } else {
            debugPrintIfDebugging('✗ No valid temperature data returned for year $year (tempData: $tempData)');
            // Mark this year as failed for tracking
            if (!_failedYears.contains(year)) {
              _failedYears.add(year);
            }
            consecutiveFailures++;
            debugPrintIfDebugging('⚠️ Consecutive failures: $consecutiveFailures/$maxConsecutiveFailures (successful: $successfulAttempts/$totalAttempts)');
          }
        } catch (e) {
          debugPrintIfDebugging('✗ Failed to fetch temperature for year $year: $e');
          
          // Track this year as failed
          if (!_failedYears.contains(year)) {
            _failedYears.add(year);
          }
          consecutiveFailures++;
          debugPrintIfDebugging('⚠️ Consecutive failures: $consecutiveFailures/$maxConsecutiveFailures (successful: $successfulAttempts/$totalAttempts)');
          
          // Check if it's a rate limit error
          if (e is RateLimitException) {
            debugPrintIfDebugging('⚠️ Rate limit exceeded for chart data, stopping further requests at year $year');
            setState(() {
              _chartDataRateLimited = true;
              _chartDataFailed = true;
              _chartDataFailedDueToRateLimit = true;
            });
            break; // Stop making more requests
          } else {
            // Other error - mark as failed but continue trying other years
            debugPrintIfDebugging('⚠️ Other error for year $year, continuing with next year');
            setState(() {
              _chartDataFailed = true;
            });
          }
        }
        
        // Add a delay to make progressive loading more visible
        await Future.delayed(const Duration(milliseconds: 100));
        
        // Log progress every 5 years to help track where it might be stalling
        if (totalAttempts % 5 == 0) {
          debugPrintIfDebugging('📊 Progress update: attempted $totalAttempts years, successful: $successfulAttempts, current year: $year');
        }
      }
      
      // Log final loading summary
      debugPrintIfDebugging('📊 Progressive loading completed - attempted: $totalAttempts years, successful: $successfulAttempts, consecutive failures: $consecutiveFailures');
      
      // Stop loading message timer when data loading completes
      _stopLoadingMessageTimer();
      _stopAverageTrendDisplayTimer(); // Stop the timer since loading completed
      _isDataLoading = false;
      _progressiveLoadingCompleted = true;
      
      // Log final results
      final successfulYears = chartData.where((data) => data.hasData).length;
      final totalYears = chartData.length;
      debugPrintIfDebugging('📊 Chart data loading completed: $successfulYears/$totalYears years loaded successfully');
      if (_failedYears.isNotEmpty) {
        debugPrintIfDebugging('❌ Failed years: $_failedYears');
      }
      if (_chartDataFailed) {
        debugPrintIfDebugging('⚠️ Chart data loading had failures - rate limited: $_chartDataFailedDueToRateLimit');
      }
      
      // Start auto-retry timer if there are failed endpoints
      if (_averageDataFailed || _trendDataFailed || _summaryDataFailed) {
        _startAutoRetryTimer();
      }
      
    } catch (e) {
      debugPrintIfDebugging('_loadChartDataProgressive failed: $e');
      
      // Stop loading message timer on error
      _stopLoadingMessageTimer();
      _stopAverageTrendDisplayTimer(); // Stop the timer on error too
      _isDataLoading = false;
      _progressiveLoadingCompleted = true;
      
      // Ensure we still have some data structure even on error
      if (_currentData == null) {
        // Create minimal data structure to show error state
        final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
        final dateToUse = DateTime.parse(dateInfo['date']!);
        final city = dateInfo['city']!;
        
        _currentData = _createResultMap(
          chartData: <TemperatureChartData>[],
          averageTemperature: null,
          trendSlope: null,
          summaryText: null,
          dateToUse: dateToUse,
          city: city,
        );
      }
      
      rethrow;
    } finally {
      // Always reset the loading operation flag and ensure loading is marked as completed
      _isLoadingOperationActive = false;
      _isDataLoading = false;
      _progressiveLoadingCompleted = true;
    }
  }






  Future<void> _handleRefresh() async {
    debugPrintIfDebugging('Pull-to-refresh triggered');
    
    // Cancel any existing background refresh to prevent race conditions
    
    // Stop any existing auto-retry timer
    _stopAutoRetryTimer();
    
    // Reset error states
    _resetErrorStates();
    
    // Clear cache in simulation mode to ensure fresh data loading
    if (AppConfig.enableEndpointFailureSimulation) {
      await _clearCache();
    }
    
    // Reset location determination state
    setState(() {
      _isLocationDetermined = false;
      _determinedLocation = '';
      _displayLocation = '';
      _locationDeterminedAt = null;
    });
    
    // Reinitialize the app (determine location then load data)
    await _initializeApp();
    
    // Don't await the future here - let the FutureBuilder handle it
    // This allows the RefreshIndicator to complete its animation
  }

  /// Force refresh without using cache (for debugging/testing)
  Future<void> _handleForceRefresh() async {
    debugPrintIfDebugging('Force refresh triggered - clearing all cache');
    
    // Clear all cache to force fresh data loading
    await _clearCache();
    
    // Cancel any existing background refresh to prevent race conditions
    _stopAutoRetryTimer();
    
    // Reset error states
    _resetErrorStates();
    
    // Reset location determination state
    setState(() {
      _isLocationDetermined = false;
      _determinedLocation = '';
      _displayLocation = '';
      _locationDeterminedAt = null;
    });
    
    // Reinitialize the app (determine location then load data)
    await _initializeApp();
  }

  /// Clear only location cache (for testing different locations in Simulator)
  Future<void> _handleLocationRefresh() async {
    debugPrintIfDebugging('Location refresh triggered - clearing location cache only');
    
    // Clear only location cache
    await _clearLocationCache();
    
    // Cancel any existing background refresh to prevent race conditions
    _stopAutoRetryTimer();
    
    // Reset error states
    _resetErrorStates();
    
    // Reset location determination state
    setState(() {
      _isLocationDetermined = false;
      _determinedLocation = '';
      _displayLocation = '';
      _locationDeterminedAt = null;
    });
    
    // Reinitialize the app (determine location then load data)
    await _initializeApp();
  }

  Widget _buildRefreshIndicator(Widget child) {
    debugPrintIfDebugging('_buildRefreshIndicator: futureChartData=${futureChartData != null}, _currentData=${_currentData != null}, _isDataLoading=$_isDataLoading');
    
    // In test mode, don't create RefreshIndicator to avoid async operations
    if (widget.testFuture != null) {
      debugPrintIfDebugging('_buildRefreshIndicator: Test mode, returning child without RefreshIndicator');
      return child;
    }
    
    // Show RefreshIndicator when we have data (either futureChartData or _currentData)
    // This ensures pull-to-refresh works in both old and new loading systems
    if (futureChartData == null && _currentData == null) {
      debugPrintIfDebugging('_buildRefreshIndicator: No data, returning child without RefreshIndicator');
      return child;
    }
    
    // Show RefreshIndicator with refresh function
    debugPrintIfDebugging('_buildRefreshIndicator: Showing RefreshIndicator');
    return RefreshIndicator(
      onRefresh: _handleRefresh,
      color: kAccentColour,
      backgroundColor: kBackgroundColour,
      child: child,
    );
  }

  Widget _buildFutureBuilder({required double chartHeight}) {
    // In test mode, use FutureBuilder to handle test data
    if (widget.testFuture != null) {
      return FutureBuilder<Map<String, dynamic>?>(
        future: widget.testFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return _buildLoadingSection();
          } else if (snapshot.hasError) {
            return _buildRetrySection(
              'Error loading data: ${snapshot.error}',
              () {
                // In test mode, we can't really retry, but this satisfies the interface
              },
            );
          } else if (snapshot.hasData) {
            final data = snapshot.data!;
            return _buildChartContent(
              chartData: data['chartData'] as List<TemperatureChartData>,
              averageTemperature: data['averageTemperature'] as double?,
              trendSlope: data['trendSlope'] as double?,
              summaryText: data['summary'] as String?,
              displayDate: data['displayDate'] as String?,
              city: data['city'] as String?,
              chartHeight: chartHeight,
            );
          } else {
            return _buildLoadingSection();
          }
        },
      );
    }
    
    // Show loading section if we don't have any data yet
    if (_currentData == null) {
      return _buildLoadingSection();
    }
    
    final data = _currentData!;
    final chartData = data['chartData'] as List<TemperatureChartData>;
    
    // If we're loading and have no data yet, show loading state
    if (chartData.isEmpty && _isDataLoading) {
      return _buildChartWithEmptyBars(
        chartData, 
        data['averageTemperature'] as double?, 
        data['trendSlope'] as double?, 
        data['summary'] as String?, 
        data['displayDate'] as String?, 
        _displayLocation.isNotEmpty ? _displayLocation : (data['city'] as String?), 
        chartHeight, 
      );
    }
    
    // Show no chart data state with retry button (only if we have no data at all and not loading)
    // Only show this if progressive loading has completed - this prevents flash during loading transitions
    if (chartData.isEmpty && !_isDataLoading && _progressiveLoadingCompleted) {
      final isRateLimited = _averageDataRateLimited || _trendDataRateLimited || _summaryDataRateLimited || _chartDataRateLimited;
      
      return _buildRetrySection(
        isRateLimited 
          ? 'API rate limit exceeded. Please wait a few minutes before trying again.'
          : 'No temperature data available. Please check your internet connection and try again.',
        isRateLimited ? null : () {
          debugPrintIfDebugging('Retry button pressed after no data');
          _handleRefresh();
        },
      );
    }
    
    
    final averageTemperature = data['averageTemperature'] as double?;
    final trendSlope = data['trendSlope'] as double?;
    final summaryText = data['summary'] as String?;
    final displayDate = data['displayDate'] as String?;
    // Use display location instead of full location from API data
    final city = _displayLocation.isNotEmpty ? _displayLocation : (data['city'] as String?);
    
    debugPrintIfDebugging('Average temperature for plot band: $averageTemperature°C');

    return _buildChartContent(
      chartData: chartData, // Pass all chart data (including empty placeholders)
      averageTemperature: averageTemperature,
      trendSlope: trendSlope,
      summaryText: summaryText,
      displayDate: displayDate,
      city: city,
      chartHeight: chartHeight,
    );
  }

  Widget _buildRetryButton(VoidCallback onPressed) {
    return ElevatedButton(
      onPressed: onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: kAccentColour,
      ),
      child: const Text(
        'Retry',
        style: TextStyle(color: kTextPrimaryColour),
      ),
    );
  }

  Widget _buildRetrySection(String message, VoidCallback? onRetry) {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Center(
          child: Container(
            width: contentWidth,
            margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  message,
                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody),
                  textAlign: TextAlign.left,
                ),
                if (onRetry != null) ...[
                  const SizedBox(height: 16),
                  _buildRetryButton(onRetry),
                ],
              ],
            ),
          ),
        );
      },
    );
  }


  Widget _buildLoadingSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Date section - show as soon as we have it
        _buildLoadingDateSection(),
        
        // Location section - show the determined location
        if (_isLocationDetermined)
          _buildDeterminedLocationSection()
        else
          _buildLocationDeterminingSection(),
        
        // Progressive loading messages - show below location
        if (_isLocationDetermined)
          _buildProgressiveLoadingSection(),
      ],
    );
  }

  Widget _buildLoadingDateSection() {
    // Calculate the date that will be used (same logic as _loadChartData)
    final dateInfo = _getCurrentDateAndLocation(_determinedLocation);
    final dateToUse = DateTime.parse(dateInfo['date']!);
    final displayDate = _formatDayMonth(dateToUse);
    
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Text(
          displayDate,
          style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
          textAlign: TextAlign.left,
        ),
    );
  }

  Widget _buildDeterminedLocationSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Text(
          _displayLocation,
          style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
          textAlign: TextAlign.left,
        ),
    );
  }

  Widget _buildLocationDeterminingSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(
                width: 24,
                height: 24,
                child: CircularProgressIndicator(
                  strokeWidth: 2.5,
                  color: kGreyLabelColour,
                ),
              ),
              const SizedBox(height: 12),
              Text(
                'Determining your location...',
                style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 1, fontWeight: FontWeight.w400),
                textAlign: TextAlign.left,
              ),
            ],
          ),
          const SizedBox(height: 16),
          Text(
            'Once we know your location, we\'ll fetch temperature data for your area.',
            style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2),
            textAlign: TextAlign.left,
          ),
        ],
      ),
    );
  }

  Widget _buildProgressiveLoadingSection() {
    return Padding(
      padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Large spinner above the text
          const SizedBox(
            width: 32,
            height: 32,
            child: CircularProgressIndicator(
              strokeWidth: 3,
              color: kGreyLabelColour,
            ),
          ),
          const SizedBox(height: 16),
          // Loading message below the spinner
          Text(
            _currentLoadingMessage.isNotEmpty 
              ? _currentLoadingMessage 
              : 'Loading temperature data...',
            style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 1, fontWeight: FontWeight.w400),
            textAlign: TextAlign.left,
          ),
        ],
      ),
    );
  }

  Widget _buildGradientBackground() {
    return SizedBox.expand(
      child: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Color(0xFF242456), // Top color
              Color(0xFF343499), // Bottom color
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTitleLogoSection() {
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Row(
          children: [
            Builder(
              builder: (context) {
                final screenWidth = MediaQuery.of(context).size.width;
                final isTablet = screenWidth >= 768;
                
                // Only apply transform on phones to align logo with content
                // On tablets, logo doesn't need to align with anything
                final logoWidget = Padding(
                  padding: const EdgeInsets.only(right: kTitleRowIconRightPadding),
                  child: SvgPicture.asset(
                    'assets/logo.svg',
                    width: 40,
                    height: 40,
                  ),
                );
                
                return isTablet 
                  ? logoWidget 
                  : Transform.translate(
                      offset: const Offset(-8.0, 0.0), // Shift logo 8px left to compensate for SVG's internal left margin
                      child: logoWidget,
                    );
              },
            ),
            Text(
              kAppTitle,
              style: TextStyle(
                color: kAccentColour,
                fontSize: kFontSizeTitle,
                fontWeight: FontWeight.bold,
                letterSpacing: 1.2,
              ),
            ),
          ],
        ),
    );
  }

  Widget _buildVersionSection() {
    return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Debug Info:',
              style: TextStyle(
                color: kGreyLabelColour,
                fontSize: kFontSizeBody - 2,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 4),
            Text(
              'Version: ${AppConfig.fullVersion}',
              style: TextStyle(
                color: kGreyLabelColour,
                fontSize: kFontSizeBody - 3,
                fontWeight: FontWeight.w400,
              ),
            ),
            Text(
              'Release: ${AppConfig.releaseDate}',
              style: TextStyle(
                color: kGreyLabelColour,
                fontSize: kFontSizeBody - 3,
                fontWeight: FontWeight.w400,
              ),
            ),
          ],
        );
  }

  Widget _buildDebugToggleSection() {
    return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Debug Mode - Simulate Endpoint Failures:',
              style: TextStyle(
                color: kGreyLabelColour,
                fontSize: kFontSizeBody - 1,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 8),
            // Use Wrap for responsive button layout
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                _buildDebugToggleButton('Average', 'average'),
                _buildDebugToggleButton('Trend', 'trend'),
                _buildDebugToggleButton('Summary', 'summary'),
                _buildResetAllButton(),
                _buildForceRefreshButton(),
                _buildLocationRefreshButton(),
              ],
            ),
            if (AppConfig.enableEndpointFailureSimulation) ...[
              const SizedBox(height: 8),
              Text(
                'Simulation Active: ${_simulateAverageFailure ? "Average" : ""}${_simulateTrendFailure ? "${_simulateAverageFailure ? ", " : ""}Trend" : ""}${_simulateSummaryFailure ? "${(_simulateAverageFailure || _simulateTrendFailure) ? ", " : ""}Summary" : ""}',
                style: TextStyle(
                  color: kAccentColour,
                  fontSize: kFontSizeBody - 2,
                  fontWeight: FontWeight.w400,
                ),
              ),
            ],
          ],
        );
  }

  Widget _buildDebugToggleButton(String label, String endpoint) {
    bool isSimulating = false;
    
    switch (endpoint) {
      case 'average':
        isSimulating = _simulateAverageFailure;
        break;
      case 'trend':
        isSimulating = _simulateTrendFailure;
        break;
      case 'summary':
        isSimulating = _simulateSummaryFailure;
        break;
    }
    
    return GestureDetector(
      onTap: () async {
        setState(() {
          switch (endpoint) {
            case 'average':
              _simulateAverageFailure = !_simulateAverageFailure;
              break;
            case 'trend':
              _simulateTrendFailure = !_simulateTrendFailure;
              break;
            case 'summary':
              _simulateSummaryFailure = !_simulateSummaryFailure;
              break;
          }
        });
        
        // Show feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('${isSimulating ? 'Disabled' : 'Enabled'} $label failure simulation'),
            duration: const Duration(seconds: 1),
          ),
        );
        
        // If we're enabling a simulation, trigger a refresh to see the failure
        if (!isSimulating) {
          // Clear cache when enabling simulation to ensure fresh data loading
          await _clearCache();
          _handleRefresh();
        }
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: isSimulating ? kAccentColour : kGreyLabelColour.withValues(alpha: 0.3),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          label,
          style: TextStyle(
            color: isSimulating ? Colors.white : kGreyLabelColour,
            fontSize: kFontSizeBody - 2,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildResetAllButton() {
    return GestureDetector(
      onTap: () {
        setState(() {
          _simulateAverageFailure = true;
          _simulateTrendFailure = false;
          _simulateSummaryFailure = false;
        });
        // Show feedback
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('All failure simulations reset'),
            duration: const Duration(seconds: 1),
          ),
        );
        // If we're enabling a simulation, trigger a refresh to see the failure
        _handleRefresh();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: kGreyLabelColour.withValues(alpha: 0.3),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          'Reset All',
          style: TextStyle(
            color: kGreyLabelColour,
            fontSize: kFontSizeBody - 2,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildForceRefreshButton() {
    return GestureDetector(
      onTap: () {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Force refresh - clearing all cache'),
            duration: Duration(seconds: 1),
          ),
        );
        _handleForceRefresh();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: kAccentColour.withValues(alpha: 0.2),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          'Force Refresh',
          style: TextStyle(
            color: kAccentColour,
            fontSize: kFontSizeBody - 2,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildLocationRefreshButton() {
    return GestureDetector(
      onTap: () {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Location refresh - clearing location cache'),
            duration: Duration(seconds: 1),
          ),
        );
        _handleLocationRefresh();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 5),
        decoration: BoxDecoration(
          color: kGreyLabelColour.withValues(alpha: 0.2),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Text(
          'Location Refresh',
          style: TextStyle(
            color: kGreyLabelColour,
            fontSize: kFontSizeBody - 2,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _buildConstrainedContent(BuildContext context, double chartHeight) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final screenWidth = MediaQuery.of(context).size.width;
        final isTablet = screenWidth >= 768;
        
        // For all tablets (both portrait and landscape), constrain the overall content area width to 650px max
        // Account for increased screen padding
        final maxContentWidth = isTablet ? 650.0 : constraints.maxWidth;
        final contentWidth = constraints.maxWidth > maxContentWidth ? maxContentWidth : constraints.maxWidth;
        final horizontalMargin = isTablet ? (constraints.maxWidth - contentWidth) / 2 : 0.0;
        
        return SizedBox(
          width: constraints.maxWidth,
          child: Center(
            child: Container(
              width: contentWidth,
              margin: EdgeInsets.symmetric(horizontal: horizontalMargin),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // --- Title/logo row: uses normal padding, not iPad indentation ---
                  _buildTitlePadding(context, _buildTitleLogoSection()),
                  // Debug features (only show when debugging)
                  if (AppConfig.shouldShowDebugFeatures) ...[
                    _buildDebugPadding(context, _buildDebugToggleSection()),
                    _buildDebugPadding(context, _buildVersionSection()),
                  ],
                  // --- The rest of the UI, including the FutureBuilder ---
                  _buildContentPadding(context, _buildFutureBuilder(chartHeight: chartHeight)),
                  // Add extra space to ensure content is always scrollable
                  _buildContentPadding(context, const SizedBox(height: 100)),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildTitlePadding(BuildContext context, Widget child) {
    return Padding(
      padding: EdgeInsets.only(
        top: MediaQuery.of(context).padding.top + kContentVerticalPadding,
        bottom: kTitleRowBottomPadding,
        left: kScreenPadding + kContentHorizontalMargin,
        right: kScreenPadding + kContentHorizontalMargin,
      ),
      child: child,
    );
  }

  Widget _buildDebugPadding(BuildContext context, Widget child) {
    final screenWidth = MediaQuery.of(context).size.width;
    final isTablet = screenWidth >= 768; // iPad threshold
    
    double leftPadding;
    double rightPadding;
    
    if (isTablet) {
      // For all iPads, align debug content with the title text (not the logo)
      final titleTextStartPosition = 40 + 6; // Logo width + right padding
      leftPadding = kScreenPadding + kContentHorizontalMargin + titleTextStartPosition;
      rightPadding = leftPadding; // Symmetric padding
    } else {
      // For phones, use the original padding
      leftPadding = kScreenPadding + kContentHorizontalMargin;
      rightPadding = kScreenPadding + kContentHorizontalMargin;
    }
    
    // Ensure padding values are non-negative
    leftPadding = leftPadding.clamp(0.0, double.infinity);
    rightPadding = rightPadding.clamp(0.0, double.infinity);
    
    return Padding(
      padding: EdgeInsets.only(
        bottom: 8.0, // Reduced bottom padding for debug sections
        left: leftPadding,
        right: rightPadding,
      ),
      child: child,
    );
  }

  Widget _buildContentPadding(BuildContext context, Widget child) {
    final screenWidth = MediaQuery.of(context).size.width;
    final isTablet = screenWidth >= 768; // iPad threshold
    
    double leftPadding;
    double rightPadding;
    
    if (isTablet) {
      // For all iPads (both portrait and landscape), align content with the title text (not the logo)
      // Calculate the position where the title text starts
      // Logo width (40) + logo right padding (6) = 46px from left edge
      // We want content to align with the title text, so we need to account for the logo's visual position
      final titleTextStartPosition = 40 + 6; // Logo width + right padding (logo stays in original position)
      leftPadding = kScreenPadding + kContentHorizontalMargin + titleTextStartPosition;
      rightPadding = leftPadding; // Symmetric padding
    } else {
      // For phones, use the original padding
      leftPadding = kScreenPadding + kContentHorizontalMargin;
      rightPadding = kScreenPadding + kContentHorizontalMargin;
    }
    
    // Ensure padding values are non-negative
    leftPadding = leftPadding.clamp(0.0, double.infinity);
    rightPadding = rightPadding.clamp(0.0, double.infinity);
    
    return Padding(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).padding.bottom + kContentVerticalPadding,
        left: leftPadding,
        right: rightPadding,
      ),
      child: child,
    );
  }

  Widget _buildChartWithEmptyBars(
    List<TemperatureChartData> chartData,
    double? averageTemperature,
    double? trendSlope,
    String? summaryText,
    String? displayDate,
    String? city,
    double chartHeight,
  ) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildDateSection(displayDate),
          _buildCitySection(city),
          _buildSummarySection(summaryText),
          _buildLoadingChartSection(chartHeight),
        ],
      ),
    );
  }

  Widget _buildDateSection(String? displayDate) {
    if (displayDate == null) return const SizedBox.shrink();
    
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Text(
        displayDate,
        style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
        textAlign: TextAlign.left,
      ),
    );
  }

  Widget _buildCitySection(String? city) {
    if (city == null) return const SizedBox.shrink();
    
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Text(
        city,
        style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
        textAlign: TextAlign.left,
      ),
    );
  }


  Widget _buildSummarySection(String? summaryText) {
    if (summaryText?.isEmpty != false) return const SizedBox.shrink();
    
    return Padding(
      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
      child: Text(
        summaryText!,
        style: TextStyle(color: kSummaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
        textAlign: TextAlign.left,
      ),
    );
  }

  Widget _buildLoadingChartSection(double chartHeight) {
    return SizedBox(
      height: chartHeight,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Large spinner above the text
          const SizedBox(
            width: 32,
            height: 32,
            child: CircularProgressIndicator(
              strokeWidth: 3,
              color: kGreyLabelColour,
            ),
          ),
          const SizedBox(height: 16),
          Text(
            'Loading temperature data...',
            style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody),
          ),
        ],
      ),
    );
  }

  Widget _buildChartContent({
    required List<TemperatureChartData> chartData,
    required double? averageTemperature,
    required double? trendSlope,
    required String? summaryText,
    required String? displayDate,
    required String? city,
    required double chartHeight,
  }) {
    // Calculate minimum and maximum temperature for Y-axis (only from years with data)
    final validData = chartData.where((data) => data.hasData).toList();
    
    // If we have chart data but no valid data yet, show the chart with empty bars
    // This allows the progressive loading to be visible
    if (validData.isEmpty) {
      // Show chart with empty bars - they won't be visible but the structure will be there
      return _buildChartWithEmptyBars(chartData, averageTemperature, trendSlope, summaryText, displayDate, city, chartHeight);
    }
    
    double yAxisMin;
    double yAxisMax;
    double minTemp = 0.0;
    double maxTemp = 0.0;
    
    minTemp = validData.map((data) => data.temperature).reduce((a, b) => a < b ? a : b);
    maxTemp = validData.map((data) => data.temperature).reduce((a, b) => a > b ? a : b);
    
    // Calculate dynamic Y-axis range based on actual data
    // Add padding above and below the data range for better visualization
    yAxisMin = (minTemp - 2).floorToDouble(); // Start 2 degrees below minimum
    yAxisMax = (maxTemp + 2).ceilToDouble(); // End 2 degrees above maximum
    
    // Ensure we have a reasonable minimum range even for small temperature variations
    final range = maxTemp - minTemp;
    if (range < 5) {
      // For small ranges, ensure we have at least 5 degrees of scale
      final midPoint = (maxTemp + minTemp) / 2;
      yAxisMin = (midPoint - 2.5).floorToDouble();
      yAxisMax = (midPoint + 2.5).ceilToDouble();
    }
    
    debugPrintIfDebugging('Y-axis calculation - minTemp: $minTemp, maxTemp: $maxTemp, yAxisMin: $yAxisMin, yAxisMax: $yAxisMax');
    
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildDateSection(displayDate),
          _buildCitySection(city),
          _buildSummarySection(summaryText),
          Padding(
            padding: const EdgeInsets.all(kChartInnerPadding),
            child: Builder(
              builder: (context) {
                final screenWidth = MediaQuery.of(context).size.width;
                final isTablet = screenWidth >= 768; // iPad threshold
                
                // On tablets, constrain chart width to a reasonable maximum
                // Account for chart margins and content padding to prevent overflow
                final availableWidth = isTablet ? 600.0 : screenWidth;
                // Subtract right margin and account for content padding
                final contentPadding = kScreenPadding + kContentHorizontalMargin;
                final chartWidth = availableWidth - kChartRightMargin - (contentPadding * 2);
                
                // Create the chart widget once to avoid duplication
                final chartWidget = SfCartesianChart(
                  margin: EdgeInsets.only(
                    left: kChartHorizontalMargin, // Keep left margin consistent with text
                    right: kChartRightMargin, // Extra right margin for Y-axis labels
                  ),
                  tooltipBehavior: TooltipBehavior(
                    enable: true,
                    format: 'point.x: point.y°C',
                    canShowMarker: false,
                    header: '',
                    textStyle: TextStyle(fontSize: kFontSizeBody),
                    builder: (data, point, series, pointIndex, seriesIndex) {
                      final year = data.year;
                      final temp = data.temperature.toStringAsFixed(1);
                      return Container(
                        padding: const EdgeInsets.all(8),
                        decoration: BoxDecoration(
                          color: Colors.black87,
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          '$year: $temp°C',
                          style: TextStyle(color: Colors.white, fontSize: kFontSizeBody - 4),
                        ),
                      );
                    },
                  ),
                  series: [
                    BarSeries<TemperatureChartData, int>(
                      dataSource: chartData,
                      xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                      yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                      pointColorMapper: (TemperatureChartData data, int index) =>
                          data.isCurrentYear ? kBarCurrentYearColour : kBarOtherYearColour,
                      width: 0.8, // Restored to proper thickness
                      name: 'Yearly Temperature',
                      enableTooltip: true,
                      // Ensure consistent spacing and prevent edge cropping
                      spacing: 0.1, // Reduced spacing to maintain bar thickness
                      borderRadius: BorderRadius.circular(2),
                    ),
                    // Only show average and trend lines after all data has loaded
                    if (averageTemperature != null && !_isDataLoading)
                      LineSeries<TemperatureChartData, int>(
                        dataSource: _generateAverageData(chartData, averageTemperature),
                        xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                        yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                        color: kAverageColour,
                        width: 2,
                        name: 'Average Temperature',
                        markerSettings: MarkerSettings(isVisible: false),
                      ),
                    if (trendSlope != null && !_isDataLoading)
                      LineSeries<TemperatureChartData, int>(
                        dataSource: _generateTrendData(chartData, trendSlope),
                        xValueMapper: (TemperatureChartData data, int index) => int.parse(data.year),
                        yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                        color: kTrendColour,
                        width: 2,
                        name: 'Trend',
                        markerSettings: MarkerSettings(isVisible: false),
                      ),
                  ],
                  primaryXAxis: NumericAxis(
                    labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                    majorGridLines: MajorGridLines(width: 0.5, color: kAxisGridColour.withValues(alpha: 0.3)),
                    labelIntersectAction: AxisLabelIntersectAction.hide,
                    // For progressive loading, show the full year range (1975-2025) from the start
                    // This ensures consistent bar spacing as data loads and includes current year
                    minimum: 1975.0,
                    maximum: 2025.0,
                    interval: 5, // Show every 5th year to avoid crowding
                    labelFormat: '{value}',
                    // Ensure proper spacing and prevent cropping
                    plotOffset: 20,
                    // Show the axis line
                    axisLine: AxisLine(width: 1, color: kAxisLabelColour),
                  ),
                  primaryYAxis: NumericAxis(
                    labelFormat: '{value}°C',
                    numberFormat: NumberFormat('0'),
                    minimum: yAxisMin,
                    maximum: yAxisMax,
                    majorGridLines: MajorGridLines(width: 0.5, color: kAxisGridColour.withValues(alpha: 0.3)),
                    labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                    // Ensure bars start at the axis regardless of temperature values
                    plotOffset: 0,
                    // Force the axis to respect the exact minimum and maximum values
                    desiredIntervals: 5,
                    // Add margin for Y-axis labels
                    labelPosition: ChartDataLabelPosition.outside,
                    // Show the axis line
                    axisLine: AxisLine(width: 1, color: kAxisLabelColour),
                  ),
                  plotAreaBorderWidth: 0,
                  enableAxisAnimation: false, // Disable animation to prevent layout shifting
                  // Ensure proper spacing for bars
                );
                
                return isTablet 
                  ? SizedBox(
                      height: chartHeight,
                      width: chartWidth,
                      child: chartWidget,
                    )
                  : Center(
                      child: SizedBox(
                        height: chartHeight,
                        width: chartWidth,
                        child: chartWidget,
                      ),
                    );
              },
            ),
          ),
          // Consistent spacing below chart - always show this
          const SizedBox(height: kSectionTopPadding),
          // Average temperature text below chart (only show after loading)
          if (averageTemperature != null && !_isDataLoading)
            Padding(
              padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
              child: Text(
                'Average: ${averageTemperature.toStringAsFixed(1)}°C',
                style: TextStyle(color: kAverageColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                textAlign: TextAlign.left,
              ),
            ),
          // Average data error message if it failed
          if (_averageDataFailed)
            Padding(
              padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
              child: Row(
                children: [
                  Icon(
                    _isRetryingAverage ? Icons.hourglass_empty : 
                    _averageDataRateLimited ? Icons.timer : Icons.error_outline,
                    color: _isRetryingAverage ? kGreyLabelColour : 
                           _averageDataRateLimited ? kGreyLabelColour : kAccentColour,
                    size: kIconSize,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _isRetryingAverage 
                        ? 'Retrying average temperature data...'
                        : _averageDataRateLimited 
                          ? 'Rate limit exceeded - please wait before retrying'
                          : 'Failed to load average temperature data',
                      style: TextStyle(
                        color: _isRetryingAverage ? kGreyLabelColour : 
                               _averageDataRateLimited ? kGreyLabelColour : kAccentColour, 
                        fontSize: kFontSizeBody - 1, 
                        fontWeight: FontWeight.w400
                      ),
                      textAlign: TextAlign.left,
                    ),
                  ),
                  if (!_isRetryingAverage && !_averageDataRateLimited) ...[
                    const SizedBox(width: 8),
                    GestureDetector(
                      onTap: _retryAverageData,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: kAccentColour.withValues(alpha: 0.2),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          'Retry',
                          style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            ),
          // Trend text below chart (only show after loading)
          if (trendSlope != null && !_isDataLoading)
            Padding(
              padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
              child: Text(
                trendSlope.abs() < 0.05
                  ? 'Trend: Steady at ${trendSlope.abs().toStringAsFixed(1)}°C/decade'
                  : trendSlope > 0 
                    ? 'Trend: Rising at ${trendSlope.abs().toStringAsFixed(1)}°C/decade'
                    : 'Trend: Falling at ${trendSlope.abs().toStringAsFixed(1)}°C/decade',
                style: TextStyle(color: kTrendColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                textAlign: TextAlign.left,
              ),
            ),
          // Trend data error message if it failed
          if (_trendDataFailed)
            Padding(
              padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
              child: Row(
                children: [
                  Icon(
                    _isRetryingTrend ? Icons.hourglass_empty : Icons.error_outline,
                    color: _isRetryingTrend ? kGreyLabelColour : kAccentColour,
                    size: kIconSize,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _isRetryingTrend 
                        ? 'Retrying trend data...'
                        : _trendDataRateLimited 
                          ? 'Rate limit exceeded - please wait before retrying'
                          : 'Failed to load trend data',
                      style: TextStyle(
                        color: _isRetryingTrend ? kGreyLabelColour : 
                               _trendDataRateLimited ? kGreyLabelColour : kAccentColour, 
                        fontSize: kFontSizeBody - 1, 
                        fontWeight: FontWeight.w400
                      ),
                      textAlign: TextAlign.left,
                    ),
                  ),
                  if (!_isRetryingTrend && !_trendDataRateLimited) ...[
                    const SizedBox(width: 8),
                    GestureDetector(
                      onTap: _retryTrendData,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: kAccentColour.withValues(alpha: 0.2),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          'Retry',
                          style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            ),
          // Summary error message if it failed
          if (_summaryDataFailed)
            Padding(
              padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
              child: Row(
                children: [
                  Icon(
                    _isRetryingSummary ? Icons.hourglass_empty : Icons.error_outline,
                    color: _isRetryingSummary ? kGreyLabelColour : kAccentColour,
                    size: kIconSize,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      _isRetryingSummary 
                        ? 'Retrying summary data...'
                        : _summaryDataRateLimited 
                          ? 'Rate limit exceeded - please wait before retrying'
                          : 'Failed to load summary data',
                      style: TextStyle(
                        color: _isRetryingSummary ? kGreyLabelColour : 
                               _summaryDataRateLimited ? kGreyLabelColour : kAccentColour, 
                        fontSize: kFontSizeBody - 1, 
                        fontWeight: FontWeight.w400
                      ),
                      textAlign: TextAlign.left,
                    ),
                  ),
                  if (!_isRetryingSummary && !_summaryDataRateLimited) ...[
                    const SizedBox(width: 8),
                    GestureDetector(
                      onTap: _retrySummaryData,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: kAccentColour.withValues(alpha: 0.2),
                          borderRadius: BorderRadius.circular(4),
                        ),
                        child: Text(
                          'Retry',
                          style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            ),
          // Data completeness indicator
          _buildDataCompletenessIndicator(chartData),
        ],
      ),
    );
  }

  Widget _buildDataCompletenessIndicator(List<TemperatureChartData> chartData) {
    // Only show completeness indicator if we're not currently loading data AND progressive loading has completed
    if (_isDataLoading || !_progressiveLoadingCompleted) {
      return const SizedBox.shrink();
    }
    
    final missingYears = chartData.where((data) => !data.hasData).map((data) => int.parse(data.year)).toList();
    final hasGaps = missingYears.isNotEmpty || _chartDataHasGaps || _chartDataFailed;
    
    debugPrintIfDebugging('📊 Data completeness check - missing years: $missingYears, hasGaps: $hasGaps, chartDataFailed: $_chartDataFailed, progressiveLoadingCompleted: $_progressiveLoadingCompleted');
    
    // Check for missing recent years (2022-2025) - but only if we actually attempted to load them
    final currentYear = DateTime.now().year;
    final recentYears = List.generate(currentYear - 2021, (index) => 2022 + index);
    final missingRecentYears = recentYears.where((year) => 
      !chartData.any((data) => int.parse(data.year) == year && data.hasData)
    ).toList();
    
    // Also check if we have very few data points (less than 10 years of data)
    final successfulYears = chartData.where((data) => data.hasData).length;
    final hasVeryLittleData = successfulYears < 10;
    
    // Debug log the user-facing messages
    if (hasGaps || missingRecentYears.isNotEmpty || hasVeryLittleData) {
      debugPrintIfDebugging('📝 Showing data completeness message - missingYears: $missingYears, missingRecentYears: $missingRecentYears, hasVeryLittleData: $hasVeryLittleData, successfulYears: $successfulYears');
    }
    
    if (hasGaps || missingRecentYears.isNotEmpty || hasVeryLittleData) {
      return Padding(
        padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Show chart data failure message if there was a failure
            if (_chartDataFailed) _buildChartDataFailureMessage(),
            // Show missing years text or low data warning
            if (missingYears.isNotEmpty || missingRecentYears.isNotEmpty || hasVeryLittleData) ...[
              const SizedBox(height: 8),
              Builder(
                builder: (context) {
                  String message;
                  if (hasVeryLittleData && missingYears.isEmpty && missingRecentYears.isEmpty) {
                    message = 'Note: Very limited data available for this location. Only $successfulYears years of data were loaded.';
                    debugPrintIfDebugging('📝 User message: $message');
                  } else {
                    message = 'Note: ${_buildMissingYearsText(missingYears, missingRecentYears)}.';
                    debugPrintIfDebugging('📝 User message: $message');
                  }
                  
                  return Text(
                    message,
                    style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                    textAlign: TextAlign.left,
                  );
                },
              ),
            ],
            const SizedBox(height: 4),
            Text(
              'Data completeness: ${((chartData.where((data) => data.hasData).length / chartData.length) * 100).toStringAsFixed(0)}%',
              style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
              textAlign: TextAlign.left,
            ),
            _buildDataRetrySection(),
            _buildRetryAttemptsOrInfoSection(),
          ],
        ),
      );
    }
    return const SizedBox.shrink();
  }

  String _buildMissingYearsText(List<int> missingYears, List<int> missingRecentYears) {
    // Sort missing years for better display
    missingYears.sort();
    
    // Group consecutive missing years for cleaner display
    final missingRanges = _groupConsecutiveYears(missingYears);
    
    String missingText;
    if (missingRanges.length == 1 && missingRanges.first.length == 1) {
      // Single year missing
      missingText = 'Year ${missingRanges.first.first} is missing';
    } else if (missingRanges.length == 1) {
      // Consecutive years missing
      missingText = 'Years ${missingRanges.first.first}-${missingRanges.first.last} are missing';
    } else {
      // Multiple ranges missing
      final ranges = missingRanges.map((range) {
        if (range.length == 1) return range.first.toString();
        return '${range.first}-${range.last}';
      }).join(', ');
      missingText = 'Years $ranges are missing';
    }
    
    // Only add note about missing recent years if they were actually attempted to be loaded
    // and are genuinely missing (not just not yet attempted due to timeout)
    if (missingRecentYears.isNotEmpty) {
      final recentRanges = _groupConsecutiveYears(missingRecentYears);
      String recentText;
      if (recentRanges.length == 1 && recentRanges.first.length == 1) {
        recentText = 'Year ${recentRanges.first.first}';
      } else if (recentRanges.length == 1) {
        recentText = 'Years ${recentRanges.first.first}-${recentRanges.first.last}';
      } else {
        final ranges = recentRanges.map((range) {
          if (range.length == 1) return range.first.toString();
          return '${range.first}-${range.last}';
        }).join(', ');
        recentText = 'Years $ranges';
      }
      
      if (missingText.isNotEmpty) {
        missingText += '. Recent data ($recentText) is not yet available';
      } else {
        missingText = 'Recent data ($recentText) is not yet available';
      }
    }
    
    debugPrintIfDebugging('📝 Generated missing years text: "$missingText"');
    return missingText;
  }

  Widget _buildChartDataFailureMessage() {
    String message;
    if (_isRetryingChartData) {
      message = 'Retrying chart data...';
    } else if (_chartDataFailedDueToRateLimit) {
      message = 'API rate limit exceeded - please wait before retrying chart data';
    } else {
      message = 'Failed to load some chart data';
    }
    
    debugPrintIfDebugging('📝 Chart data failure message: "$message"');
    
    return Row(
      children: [
        Icon(
          _isRetryingChartData ? Icons.hourglass_empty : 
          _chartDataFailedDueToRateLimit ? Icons.timer : Icons.error_outline,
          color: _isRetryingChartData ? kGreyLabelColour : 
                 _chartDataFailedDueToRateLimit ? kGreyLabelColour : kAccentColour,
          size: kIconSize,
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Text(
            message,
            style: TextStyle(
              color: _isRetryingChartData ? kGreyLabelColour : 
                     _chartDataFailedDueToRateLimit ? kGreyLabelColour : kAccentColour, 
              fontSize: kFontSizeBody - 1, 
              fontWeight: FontWeight.w400
            ),
            textAlign: TextAlign.left,
          ),
        ),
        if (!_isRetryingChartData && !_chartDataFailedDueToRateLimit) ...[
          const SizedBox(width: 8),
          GestureDetector(
            onTap: _retryChartData,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: kAccentColour.withValues(alpha: 0.2),
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                'Retry',
                style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
              ),
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildDataRetrySection() {
    if (_chartDataRetryCount >= _maxChartDataRetries) {
      return const SizedBox.shrink();
    }
    
    // Only show the general retry section if there's no specific chart data failure
    if (_chartDataFailed) {
      return const SizedBox.shrink();
    }
    
    return Column(
      children: [
        const SizedBox(height: 8),
        Row(
          children: [
            Icon(
              _isRetryingChartData ? Icons.hourglass_empty : Icons.refresh,
              color: _isRetryingChartData ? kGreyLabelColour : kAccentColour,
              size: kIconSize,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Text(
                _isRetryingChartData 
                  ? 'Retrying chart data...'
                  : 'Missing data may be temporary. Try refreshing.',
                style: TextStyle(
                  color: kGreyLabelColour, 
                  fontSize: kFontSizeBody - 2, 
                  fontWeight: FontWeight.w400
                ),
                textAlign: TextAlign.left,
              ),
            ),
            if (!_isRetryingChartData) ...[
              const SizedBox(width: 8),
              GestureDetector(
                onTap: _retryChartData,
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: kAccentColour.withValues(alpha: 0.2),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    'Retry',
                    style: TextStyle(color: kAccentColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w500),
                  ),
                ),
              ),
            ],
          ],
        ),
      ],
    );
  }

  Widget _buildRetryAttemptsOrInfoSection() {
    if (_chartDataRetryCount > 0) {
      return Column(
        children: [
          const SizedBox(height: 4),
          Text(
            'Retry attempts: $_chartDataRetryCount/$_maxChartDataRetries',
            style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 3, fontWeight: FontWeight.w400),
            textAlign: TextAlign.left,
          ),
        ],
      );
    } else {
      // Only show the "genuinely incomplete" message if we didn't hit a timeout
      // and we have a reasonable amount of data (more than 10 years)
      final successfulYears = _currentData != null ? 
        (_currentData!['chartData'] as List<TemperatureChartData>).where((data) => data.hasData).length : 0;
      
      if (!_chartDataFailed && successfulYears >= 10) {
        const message = 'Data appears to be incomplete for this location. Some years may not have data available.';
        debugPrintIfDebugging('📝 User message: $message');
        
        return Column(
          children: [
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(
                  Icons.info_outline,
                  color: kGreyLabelColour,
                  size: kIconSize,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    message,
                    style: TextStyle(
                      color: kGreyLabelColour, 
                      fontSize: kFontSizeBody - 2, 
                      fontWeight: FontWeight.w400
                    ),
                    textAlign: TextAlign.left,
                  ),
                ),
              ],
            ),
          ],
        );
      } else {
        // Don't show the "incomplete" message if we hit a timeout or have very little data
        debugPrintIfDebugging('📝 Skipping "incomplete" message - chartDataFailed: $_chartDataFailed, successfulYears: $successfulYears');
        return const SizedBox.shrink();
      }
    }
  }

  /// Group consecutive years into ranges for cleaner display
  List<List<int>> _groupConsecutiveYears(List<int> years) {
    if (years.isEmpty) return [];
    
    final sortedYears = List<int>.from(years)..sort();
    final ranges = <List<int>>[];
    List<int> currentRange = [sortedYears.first];
    
    for (int i = 1; i < sortedYears.length; i++) {
      if (sortedYears[i] == sortedYears[i - 1] + 1) {
        // Consecutive year, add to current range
        currentRange.add(sortedYears[i]);
      } else {
        // Gap found, save current range and start new one
        ranges.add(List<int>.from(currentRange));
        currentRange = [sortedYears[i]];
      }
    }
    
    // Add the last range
    ranges.add(currentRange);
    return ranges;
  }

  void _startListeningToLocationChanges() {
    _positionStreamSubscription = geo.Geolocator.getPositionStream(
      locationSettings: geo.LocationSettings(
        accuracy: geo.LocationAccuracy.low,
        distanceFilter: 500, // meters, adjust as needed
      ),
    ).listen((geo.Position position) async {
      if (_lastPosition == null ||
          _distanceBetween(_lastPosition!, position) > 1000) { // 1km threshold
        _lastPosition = position;
        
        // Don't start new data loading if we're already loading or if location hasn't been determined yet
        if (_isDataLoading || _isLoadingOperationActive || !_isLocationDetermined) {
          debugPrintIfDebugging('Skipping location change - already loading: $_isDataLoading, operation active: $_isLoadingOperationActive, location determined: $_isLocationDetermined');
          return;
        }
        
        debugPrintIfDebugging('Significant location change detected, refreshing data...');
        
        // Check if the city has actually changed before reloading data
        try {
          List<Placemark> placemarks = await placemarkFromCoordinates(
            position.latitude, 
            position.longitude
          ).timeout(const Duration(seconds: 5));
          
          if (placemarks.isNotEmpty) {
            final placemark = placemarks.first;
            String newCity = kDefaultLocation; // Default fallback
            
            if (placemark.locality != null && placemark.locality!.isNotEmpty) {
              final locality = placemark.locality!;
              final country = placemark.country;
              final administrativeArea = placemark.administrativeArea;
              
              // Build location string same way as _determineLocation
              if (country != null && country.isNotEmpty) {
                if (administrativeArea != null && administrativeArea.isNotEmpty) {
                  newCity = '$locality, $administrativeArea, $country';
                } else {
                  newCity = '$locality, $country';
                }
              } else if (administrativeArea != null && administrativeArea.isNotEmpty) {
                newCity = '$locality, $administrativeArea';
              } else {
                newCity = locality;
              }
            }
            
            newCity = _cleanupLocationString(newCity);
            
            // Only reload if the city has actually changed
            if (newCity != _determinedLocation) {
              debugPrintIfDebugging('City changed from $_determinedLocation to $newCity, refreshing data');
              await _refreshLocationAndData();
            } else {
              debugPrintIfDebugging('Location change detected but city is the same, no refresh needed');
            }
          }
        } catch (e) {
          debugPrintIfDebugging('Error checking location change: $e');
        }
      }
    });
  }

  double _distanceBetween(geo.Position a, geo.Position b) {
    return geo.Geolocator.distanceBetween(
      a.latitude, a.longitude, b.latitude, b.longitude,
    );
  }

  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    // Show splash screen while app is initializing OR minimum time hasn't elapsed
    // Skip splash screen in test mode
    if (widget.testFuture == null && (!_isAppInitialized || !_splashScreenMinTimeElapsed)) {
      return const SplashScreen();
    }
    
    final double chartHeight = 800;

    Widget appContent = Scaffold(
      body: Stack(
        children: [
          // Gradient background fills the whole screen including system areas
          _buildGradientBackground(),
          // Foreground content scrolls above the background
          _buildRefreshIndicator(
            SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: _buildConstrainedContent(context, chartHeight),
            ),
          ),
        ],
      ),
    );

    // Wrap with AnnotatedRegion for mobile platforms
    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
        // iOS uses statusBarBrightness, Android uses statusBarIconBrightness
        statusBarBrightness: Platform.isIOS ? Brightness.dark : null,
        statusBarIconBrightness: Platform.isIOS ? null : Brightness.light,
      ),
      child: appContent,
    );
  }

  /// Simulate endpoint failures for testing purposes
  Future<T> _simulateEndpointFailure<T>(String endpointName, Future<T> Function() apiCall) async {
    if (!AppConfig.enableEndpointFailureSimulation) {
      return await apiCall();
    }
    
    // Simulate different failure scenarios based on state
    if (endpointName == 'average' && _simulateAverageFailure) {
      debugPrintIfDebugging('Simulating average endpoint failure');
      await Future.delayed(const Duration(seconds: 2)); // Simulate delay
      throw Exception('Simulated average endpoint failure for testing');
    }
    
    if (endpointName == 'trend' && _simulateTrendFailure) {
      debugPrintIfDebugging('Simulating trend endpoint failure');
      await Future.delayed(const Duration(seconds: 2)); // Simulate delay
      throw Exception('Simulated trend endpoint failure for testing');
    }
    
    if (endpointName == 'summary' && _simulateSummaryFailure) {
      debugPrintIfDebugging('Simulating summary endpoint failure');
      await Future.delayed(const Duration(seconds: 2)); // Simulate delay
      throw Exception('Simulated summary endpoint failure for testing');
    }
    
    // If no failure is simulated, proceed with normal call
    return await apiCall();
  }
}

class TemperatureChartData {
  final String year;
  final double temperature;
  final bool isCurrentYear;
  final bool hasData; // Added for gap handling

  TemperatureChartData({
    required this.year,
    required this.temperature,
    required this.isCurrentYear,
    this.hasData = true, // Default to true
  });
}

List<TemperatureChartData> _generateTrendData(List<TemperatureChartData> chartData, double slope) {
  if (chartData.isEmpty) return [];
  
  // Find the middle year to use as reference point (only from years with data)
  final yearsWithData = chartData.where((data) => data.hasData).map((data) => int.parse(data.year)).toList();
  if (yearsWithData.isEmpty) return [];
  
  yearsWithData.sort();
  final middleYear = yearsWithData[yearsWithData.length ~/ 2];
  
  // Calculate the middle temperature (average of all temperatures with data)
  final tempsWithData = chartData.where((data) => data.hasData).map((data) => data.temperature).toList();
  final middleTemp = tempsWithData.reduce((a, b) => a + b) / tempsWithData.length;
  
  // Generate trend line points for all years in chronological order
  final allYears = yearsWithData;
  final minYear = allYears.first;
  final maxYear = allYears.last;
  
  List<TemperatureChartData> trendData = [];
  for (int year = minYear; year <= maxYear; year++) {
    final yearsFromMiddle = year - middleYear;
    final trendTemp = middleTemp + (slope * yearsFromMiddle / 10); // Convert decade slope to yearly
    
    trendData.add(TemperatureChartData(
      year: year.toString(),
      temperature: trendTemp,
      isCurrentYear: year == DateTime.now().year,
      hasData: true,
    ));
  }
  
  return trendData;
}

List<TemperatureChartData> _generateAverageData(List<TemperatureChartData> chartData, double averageTemp) {
  if (chartData.isEmpty) return [];
  
  // Generate average line points for all years in chronological order
  final yearsWithData = chartData.where((data) => data.hasData).map((data) => int.parse(data.year)).toList();
  if (yearsWithData.isEmpty) return [];
  
  yearsWithData.sort();
  final minYear = yearsWithData.first;
  final maxYear = yearsWithData.last;
  
  List<TemperatureChartData> averageData = [];
  for (int year = minYear; year <= maxYear; year++) {
    averageData.add(TemperatureChartData(
      year: year.toString(),
      temperature: averageTemp,
      isCurrentYear: year == DateTime.now().year,
      hasData: true,
    ));
  }
  
  return averageData;
}

String _formatDayMonth(DateTime date) {
  final day = date.day;
  final month = DateFormat('MMMM').format(date);
  String suffix;
  if (day >= 11 && day <= 13) {
    suffix = 'th';
  } else {
    switch (day % 10) {
      case 1:
        suffix = 'st';
        break;
      case 2:
        suffix = 'nd';
        break;
      case 3:
        suffix = 'rd';
        break;
      default:
        suffix = 'th';
    }
  }
  return '$day$suffix $month';
}

Map<String, dynamic> _createResultMap({
  required List<TemperatureChartData> chartData,
  required double? averageTemperature,
  required double? trendSlope,
  required String? summaryText,
  required DateTime dateToUse,
  required String city,
}) {
  return {
    'chartData': chartData,
    'averageTemperature': averageTemperature,
    'trendSlope': trendSlope,
    'summary': summaryText,
    'displayDate': _formatDayMonth(dateToUse),
    'city': city,
  };
}

// Sign up
Future<UserCredential> signUp(String email, String password) async {
  return await FirebaseAuth.instance.createUserWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign in
Future<UserCredential> signIn(String email, String password) async {
  return await FirebaseAuth.instance.signInAnonymously();
}

// Sign out
Future<void> signOut() async {
  await FirebaseAuth.instance.signOut();
}
