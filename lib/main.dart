import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:geocoding/geocoding.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // This is auto-generated by FlutterFire CLI
import 'package:firebase_auth/firebase_auth.dart';
import 'package:http/http.dart' as http;
import 'package:flutter/services.dart';
import 'dart:io' show Platform;
import 'dart:async';

import 'services/temperature_service.dart';

// App color constants
const bool DEBUGGING = true;
const kBackgroundColour = Color(0xFF242456);
const kAccentColour = Color(0xFFFF6B6B);
const kTextPrimaryColour = Color(0xFFECECEC);
const kSummaryColour = Color(0xFF51CF66);
const kAverageColour = Color(0xFF4DABF7);
const kTrendColour = Color(0xFFAAAA00);
const kTrendLineColour = kTrendColour;
const kBarOtherYearColour = kAccentColour;
const kBarCurrentYearColour = kSummaryColour;
const kAxisLabelColour = Color(0xFFECECEC);
const kAxisGridColour = kAxisLabelColour;
const kGreyLabelColour = Color(0xFFB0B0B0);

// Layout constants for easy adjustment
const double kScreenPadding = 8.0;
const double kTitleRowHorizontalMargin = 4.0;
const double kTitleRowIconRightPadding = 6.0;
const double kSectionHorizontalMargin = 4.0;
const double kCitySummaryHorizontalMargin = 4.0;
const double kChartHorizontalMargin = 4.0;
const double kChartInnerPadding = 4.0;
const double kSectionBottomPadding = 22.0;
const double kSectionTopPadding = 22.0;
const double kContentVerticalPadding = 32.0; // Vertical padding for main content area

// Font size constants
const double kFontSizeTitle = 20.0;
const double kFontSizeBody = 14.0;
const double kFontSizeAxisLabel = 12.0;

void debugPrintIfDebugging(Object? message) {
  if (DEBUGGING) {
    // ignore: avoid_print
    print('DEBUG: $message');
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Configure system UI overlay to extend app background over R bar and navigation bar
  _setSystemUIOverlayStyle();
  
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  // Ensure user is signed in (anonymous)
  await _ensureSignedIn();
  runApp(MyApp());
}

void _setSystemUIOverlayStyle() {
  if (Platform.isIOS) {
    // iOS-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarBrightness: Brightness.dark, // Light text on dark background
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else if (Platform.isAndroid) {
    // Android-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light, // Light icons/text
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  }
  // For web and other platforms, use a default configuration
  else {
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
      ),
    );
  }
}

Future<void> _ensureSignedIn() async {
  final auth = FirebaseAuth.instance;
  if (auth.currentUser == null) {
    await auth.signInAnonymously();
  }
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    return MaterialApp(
      title: 'Temperature Trends',
      home: TemperatureScreen(),
    );
  }
}

class TemperatureScreen extends StatefulWidget {
  final Future<Map<String, dynamic>>? testFuture;
  final AsyncSnapshot<Map<String, dynamic>>? testSnapshot;

  TemperatureScreen({this.testFuture, this.testSnapshot});

  @override
  _TemperatureScreenState createState() => _TemperatureScreenState();
}

class _TemperatureScreenState extends State<TemperatureScreen> {
  late Future<Map<String, dynamic>> futureChartData;
  bool _hasFreshData = false;
  Timer? _dateCheckTimer;
  DateTime? _lastCheckedDate;

  @override
  void initState() {
    super.initState();
    _loadInitialData();
    _startDateCheckTimer();
  }

  @override
  void dispose() {
    _dateCheckTimer?.cancel();
    super.dispose();
  }

  void _loadInitialData() async {
    // Use test data if provided
    if (widget.testFuture != null) {
      futureChartData = widget.testFuture!;
      return;
    }
    
    // First, try to load cached data and show it immediately if available
    final cached = await _loadCachedChartData();
    bool usedCache = false;
    if (cached != null) {
      setState(() {
        futureChartData = Future.value(cached);
      });
      usedCache = true;
    } else {
      setState(() {
        futureChartData = _loadChartData();
      });
    }
    // Only try to fetch fresh data in the background if we used the cache
    if (usedCache) {
      Future.delayed(Duration.zero, () async {
        final freshFuture = _loadChartData();
        final fresh = await freshFuture;
        setState(() {
          futureChartData = Future.value(fresh);
        });
      });
    }
  }

  Future<Map<String, dynamic>> _loadChartData() async {
    final now = DateTime.now();
    final useYesterday = now.hour < 3;
    final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
    final formattedDate = DateFormat('yyyy-MM-dd').format(dateToUse);

    final service = TemperatureService();
    String city = 'London';
    // Try to get user's city via geolocation
    try {
      bool serviceEnabled = await geo.Geolocator.isLocationServiceEnabled();
      if (serviceEnabled) {
        geo.LocationPermission permission = await geo.Geolocator.checkPermission();
        if (permission == geo.LocationPermission.denied) {
          permission = await geo.Geolocator.requestPermission();
        }
        if (permission == geo.LocationPermission.whileInUse || permission == geo.LocationPermission.always) {
          geo.Position position = await geo.Geolocator.getCurrentPosition(desiredAccuracy: geo.LocationAccuracy.low);
          List<Placemark> placemarks = await placemarkFromCoordinates(position.latitude, position.longitude);
          if (placemarks.isNotEmpty && placemarks.first.locality != null && placemarks.first.locality!.isNotEmpty) {
            city = placemarks.first.locality!;
          }
        }
      }
    } catch (_) {
      // Ignore and fall back to London
    }
    final currentYear = dateToUse.year;

    List<TemperatureChartData> chartData = [];
    double? averageTemperature;
    double? trendSlope;
    String? summaryText;
    int startYear = currentYear - 50;
    int endYear = currentYear;

    // Helper to fetch year-by-year data
    Future<void> fetchYearlyData(int start, int end) async {
      for (int year = start; year <= end; year++) {
        final dateForYear = '$year-${formattedDate.substring(5)}';
        try {
          final tempData = await service.fetchTemperature(city, dateForYear);
          chartData.add(TemperatureChartData(
            year: year.toString(),
            temperature: tempData.temperature ?? tempData.average?.temperature ?? 0.0,
            isCurrentYear: year == currentYear,
          ));
        } catch (_) {}
      }
    }

    // Try main /data/ endpoint first
    try {
              debugPrintIfDebugging('Starting /data/ fetch for $city, $formattedDate');
      final tempData = await service
          .fetchCompleteData(city, '$currentYear-${formattedDate.substring(5)}')
          .timeout(const Duration(seconds: 30));
              debugPrintIfDebugging('/data/ response: ${tempData.toString()}');
        debugPrintIfDebugging('tempData.series?.data?.length: ${tempData.series?.data.length}');
      if (tempData.series?.data.isNotEmpty == true) {
        _hasFreshData = true;
        averageTemperature = tempData.average?.temperature;
        trendSlope = tempData.trend?.slope;
        summaryText = tempData.summary;

        final seriesData = tempData.series!.data;
        for (final dataPoint in seriesData) {
          if (dataPoint.y != null) {
            chartData.add(TemperatureChartData(
              year: dataPoint.x.toString(),
              temperature: (dataPoint.y is num) ? (dataPoint.y as num).toDouble() : 0.0,
              isCurrentYear: dataPoint.x == currentYear,
            ));
          }
        }
        if (tempData.average?.yearRange != null) {
          startYear = tempData.average!.yearRange.start;
          endYear = tempData.average!.yearRange.end;
        }
        final result = {
          'chartData': chartData,
          'averageTemperature': averageTemperature,
          'trendSlope': trendSlope,
          'summary': summaryText,
          'displayDate': _formatDayMonth(dateToUse),
          'city': city,
        };
        await _cacheChartData(result);
        return result;
      } else {
        debugPrintIfDebugging('/data/ returned empty or missing series');
        throw Exception('No series data in /data/ endpoint response');
      }
    } catch (e, stack) {
              debugPrintIfDebugging('Exception in /data/ fetch: $e');
        debugPrintIfDebugging('Stack trace: $stack');
      if (_hasFreshData) {
        debugPrintIfDebugging('Skipping fallback update because fresh data arrived.');
        return Future.value();
      }
      // Fallback: try /average/, /trend/, /summary/ endpoints
      try {
        debugPrintIfDebugging('Calling /average/ endpoint...');
                  debugPrintIfDebugging('formattedDate = '
              '$formattedDate');
          debugPrintIfDebugging('formattedDate.substring(5) = '
              '${formattedDate.length >= 5 ? formattedDate.substring(5) : 'INVALID'}');
        final mmdd = (formattedDate.length >= 5) ? formattedDate.substring(5) : '';
        if (mmdd.isEmpty) {
          throw Exception('Invalid date format for /average/ endpoint: $formattedDate');
        }
        final averageData = await service
            .fetchAverageData(city, mmdd)
            .timeout(const Duration(seconds: 30));
        averageTemperature = averageData['average'] != null
            ? (averageData['average'] as num).toDouble()
            : null;
        if (averageTemperature == null) {
          throw Exception('No average temperature available');
        }
        if (averageData['year_range'] != null) {
          startYear = averageData['year_range']['start'];
          endYear = averageData['year_range']['end'];
        }
        // Try to get trend and summary, but don't fail if they are missing
        debugPrintIfDebugging('Calling /trend/ endpoint...');
        try {
          final trendData = await service
              .fetchTrendData(city, mmdd)
              .timeout(const Duration(seconds: 30));
          final slope = trendData['slope'];
          trendSlope = (slope is num) ? slope.toDouble() : null;
        } catch (_) {
          trendSlope = null;
        }
        debugPrintIfDebugging('Calling /summary/ endpoint...');
        try {
          final summaryData = await service
              .fetchSummaryData(city, mmdd)
              .timeout(const Duration(seconds: 30));
          summaryText = summaryData['summary'] as String?;
        } catch (_) {
          summaryText = null;
        }
        await fetchYearlyData(startYear, endYear);
        if (_hasFreshData) {
          debugPrintIfDebugging('Skipping fallback update because fresh data arrived.');
          return Future.value();
        }
        debugPrintIfDebugging('Fallback result: averageTemperature=$averageTemperature, trendSlope=$trendSlope, summaryText=$summaryText');
        final result = {
          'chartData': chartData,
          'averageTemperature': averageTemperature,
          'trendSlope': trendSlope,
          'summary': summaryText,
          'displayDate': _formatDayMonth(dateToUse),
          'city': city,
        };
        await _cacheChartData(result);
        return result;
      } catch (_) {
        // Final fallback: just fetch year-by-year
        await fetchYearlyData(startYear, endYear);
        // No summary, average, or trend available in this fallback
        averageTemperature = null;
        trendSlope = null;
        summaryText = null;
        debugPrintIfDebugging('Final fallback (year-by-year only): averageTemperature=$averageTemperature, trendSlope=$trendSlope, summaryText=$summaryText');
        final result = {
          'chartData': chartData,
          'averageTemperature': averageTemperature,
          'trendSlope': trendSlope,
          'summary': summaryText,
          'displayDate': _formatDayMonth(dateToUse),
          'city': city,
        };
        await _cacheChartData(result);
        return result;
      }
    }
    // If all above fails, try to load from cache
    final cached = await _loadCachedChartData();
    if (cached != null) {
      return cached;
    }
    throw Exception('Failed to load data and no cached data available.');
  }

  Future<void> _cacheChartData(Map<String, dynamic> data) async {
    final prefs = await SharedPreferences.getInstance();
    // Only cache the minimal necessary data
    final cache = jsonEncode({
      'chartData': (data['chartData'] as List<TemperatureChartData>).map((e) => {
        'year': e.year,
        'temperature': e.temperature,
        'isCurrentYear': e.isCurrentYear,
      }).toList(),
      'averageTemperature': data['averageTemperature'],
      'trendSlope': data['trendSlope'],
      'summary': data['summary'],
      'displayDate': data['displayDate'],
      'city': data['city'],
      'cachedDate': DateFormat('yyyy-MM-dd').format(DateTime.now()), // Store current date
    });
    await prefs.setString('cachedChartData', cache);
  }

  Future<Map<String, dynamic>?> _loadCachedChartData() async {
    final prefs = await SharedPreferences.getInstance();
    final cache = prefs.getString('cachedChartData');
    if (cache == null) return null;
    
    final decoded = jsonDecode(cache);
    
    // Check if the date has changed since the data was cached
    final cachedDate = decoded['cachedDate'] as String?;
    final now = DateTime.now();
    final useYesterday = now.hour < 1;
    final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
    final currentDate = DateFormat('yyyy-MM-dd').format(dateToUse);
    
    if (cachedDate != null && cachedDate != currentDate) {
      // Date has changed, don't use cached data
              debugPrintIfDebugging('Date changed from $cachedDate to $currentDate, refreshing data');
      return null;
    }
    
    final chartDataList = (decoded['chartData'] as List).map((e) => TemperatureChartData(
      year: e['year'],
      temperature: (e['temperature'] is num) ? (e['temperature'] as num).toDouble() : 0.0,
      isCurrentYear: e['isCurrentYear'],
    )).toList();
    
    return {
      'chartData': chartDataList,
      'averageTemperature': decoded['averageTemperature'],
      'trendSlope': decoded['trendSlope'],
      'summary': decoded['summary'],
      'displayDate': decoded['displayDate'],
      'city': decoded['city'],
    };
  }

  void _startDateCheckTimer() {
    _dateCheckTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkDateChange();
    });
  }

  void _checkDateChange() {
    final now = DateTime.now();
    final useYesterday = now.hour < 3;
    final currentDate = useYesterday ? now.subtract(Duration(days: 1)) : now;
    
    if (_lastCheckedDate == null) {
      _lastCheckedDate = currentDate;
      return;
    }
    
    // Check if the date has changed (ignoring time)
    if (_lastCheckedDate!.year != currentDate.year ||
        _lastCheckedDate!.month != currentDate.month ||
        _lastCheckedDate!.day != currentDate.day) {
              debugPrintIfDebugging('Date changed from ${_lastCheckedDate} to $currentDate, reloading data');
      setState(() {
        futureChartData = _loadChartData();
      });
    }
    
    _lastCheckedDate = currentDate;
  }

  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly for this screen
    _setSystemUIOverlayStyle();
    
    final double chartHeight = 800;

    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: Platform.isIOS
        ? const SystemUiOverlayStyle(
            statusBarColor: Colors.transparent,
            statusBarBrightness: Brightness.dark,
            systemNavigationBarColor: Colors.transparent,
            systemNavigationBarIconBrightness: Brightness.light,
          )
        : const SystemUiOverlayStyle(
            statusBarColor: Colors.transparent,
            statusBarIconBrightness: Brightness.light,
            systemNavigationBarColor: Colors.transparent,
            systemNavigationBarIconBrightness: Brightness.light,
          ),
      child: Scaffold(
        body: Stack(
        children: [
          // Gradient background fills the whole screen including system areas
          SizedBox.expand(
            child: Container(
              decoration: const BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Color(0xFF242456), // Top color
                    Color(0xFF343499), // Bottom color
                  ],
                ),
              ),
            ),
          ),
          // Foreground content scrolls above the background
          RefreshIndicator(
            onRefresh: () async {
              setState(() {
                futureChartData = _loadChartData();
              });
              await futureChartData;
            },
            color: kAccentColour,
            backgroundColor: kBackgroundColour,
            child: SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: Padding(
                padding: EdgeInsets.only(
                  top: MediaQuery.of(context).padding.top + kContentVerticalPadding,
                  bottom: MediaQuery.of(context).padding.bottom + kContentVerticalPadding,
                  left: kScreenPadding,
                  right: kScreenPadding,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // --- Title/logo row: always visible and scrolls with content ---
                    Padding(
                      padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                      child: Align(
                        alignment: Alignment.centerLeft,
                        child: Container(
                          margin: const EdgeInsets.symmetric(horizontal: kTitleRowHorizontalMargin),
                          child: Row(
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(right: kTitleRowIconRightPadding),
                                child: SvgPicture.asset(
                                  'assets/logo.svg',
                                  width: 40,
                                  height: 40,
                                ),
                              ),
                              Text(
                                'TempHist',
                                style: TextStyle(
                                  color: kAccentColour,
                                  fontSize: kFontSizeTitle,
                                  fontWeight: FontWeight.bold,
                                  letterSpacing: 1.2,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                    ),
                    // --- The rest of your UI, including the FutureBuilder ---
                    FutureBuilder<Map<String, dynamic>>(
                      future: futureChartData,
                      builder: (context, snapshot) {
                        final effectiveSnapshot = widget.testSnapshot ?? snapshot;
                        if (effectiveSnapshot.connectionState == ConnectionState.waiting) {
                          return const Center(child: CircularProgressIndicator());
                        } else if (effectiveSnapshot.hasError) {
                          return Center(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Text(
                                  'Error loading data: ${effectiveSnapshot.error}',
                                  style: const TextStyle(color: kTextPrimaryColour),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 16),
                                ElevatedButton(
                                  onPressed: () {
                                    setState(() {
                                      futureChartData = _loadChartData();
                                    });
                                  },
                                  child: const Text(
                                    'Retry',
                                    style: TextStyle(color: kTextPrimaryColour),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: kAccentColour,
                                  ),
                                ),
                              ],
                            ),
                          );
                        } else if (!effectiveSnapshot.hasData || effectiveSnapshot.data!.isEmpty) {
                          return Center(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Text(
                                  'No temperature data available.',
                                  style: TextStyle(color: kTextPrimaryColour),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 16),
                                ElevatedButton(
                                  onPressed: () {
                                    setState(() {
                                      futureChartData = _loadChartData();
                                    });
                                  },
                                  child: const Text(
                                    'Retry',
                                    style: TextStyle(color: kTextPrimaryColour),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: kAccentColour,
                                  ),
                                ),
                              ],
                            ),
                          );
                        }

                        final data = effectiveSnapshot.data!;
                        final chartData = data['chartData'] as List<TemperatureChartData>;
                        if (chartData.isEmpty) {
                          return Center(
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Text(
                                  'No temperature data available.',
                                  style: TextStyle(color: kTextPrimaryColour),
                                  textAlign: TextAlign.center,
                                ),
                                const SizedBox(height: 16),
                                ElevatedButton(
                                  onPressed: () {
                                    setState(() {
                                      futureChartData = _loadChartData();
                                    });
                                  },
                                  child: const Text(
                                    'Retry',
                                    style: TextStyle(color: kTextPrimaryColour),
                                  ),
                                  style: ElevatedButton.styleFrom(
                                    backgroundColor: kAccentColour,
                                  ),
                                ),
                              ],
                            ),
                          );
                        }
                        final averageTemperature = data['averageTemperature'] as double?;
                        final trendSlope = data['trendSlope'] as double?;
                        final summaryText = data['summary'] as String?;
                        final displayDate = data['displayDate'] as String?;
                        final city = data['city'] as String?;
                        
                        debugPrintIfDebugging('Average temperature for plot band: $averageTemperature°C');

                        // Calculate minimum and maximum temperature for Y-axis
                        final minTemp = chartData.map((data) => data.temperature).reduce((a, b) => a < b ? a : b);
                        final maxTemp = chartData.map((data) => data.temperature).reduce((a, b) => a > b ? a : b);
                        final yAxisMin = (minTemp - 2).floorToDouble(); // Start 2 degrees below minimum
                        final yAxisMax = (maxTemp + 2).ceilToDouble(); // End 2 degrees above maximum

                        return SingleChildScrollView(
                          child: Padding(
                            padding: const EdgeInsets.all(kChartInnerPadding),
                            child: LayoutBuilder(
                              builder: (context, constraints) {
                                double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
                                return Center(
                                  child: Container(
                                    width: contentWidth,
                                    child: Column(
                                      crossAxisAlignment: CrossAxisAlignment.start,
                                      children: [
                                        // Date and location above summary
                                        if (displayDate != null)
                                          Padding(
                                            padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                                            child: Align(
                                              alignment: Alignment.centerLeft,
                                              child: Container(
                                                margin: const EdgeInsets.symmetric(horizontal: kSectionHorizontalMargin),
                                                child: Text(
                                                  displayDate,
                                                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                                  textAlign: TextAlign.left,
                                                ),
                                              ),
                                            ),
                                          ),
                                        if (city != null)
                                          Padding(
                                            padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                                            child: Align(
                                              alignment: Alignment.centerLeft,
                                              child: Container(
                                                margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                                                child: Text(
                                                  city,
                                                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                                  textAlign: TextAlign.left,
                                                ),
                                              ),
                                            ),
                                          ),
                                        if (summaryText?.isNotEmpty == true)
                                          Padding(
                                            padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                                            child: Align(
                                              alignment: Alignment.centerLeft,
                                              child: Container(
                                                margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                                                child: Text(
                                                  summaryText!,
                                                  style: TextStyle(color: kSummaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                                  textAlign: TextAlign.left,
                                                ),
                                              ),
                                            ),
                                          ),
                                        SizedBox(
                                          height: chartHeight,
                                          child: SfCartesianChart(
                                            margin: EdgeInsets.symmetric(horizontal: kChartHorizontalMargin),
                                            tooltipBehavior: TooltipBehavior(
                                              enable: true,
                                              format: 'point.x: point.y',
                                              canShowMarker: false,
                                              header: '',
                                              textStyle: TextStyle(fontSize: kFontSizeBody),
                                            ),
                                            series: [
                                              BarSeries<TemperatureChartData, String>(
                                                dataSource: chartData,
                                                xValueMapper: (TemperatureChartData data, int index) => data.year,
                                                yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                                                pointColorMapper: (TemperatureChartData data, int index) =>
                                                    data.isCurrentYear ? kBarCurrentYearColour : kBarOtherYearColour,
                                                width: 0.8,
                                                name: 'Yearly Temperature',
                                                enableTooltip: true,
                                              ),
                                              if (averageTemperature != null)
                                                LineSeries<TemperatureChartData, String>(
                                                  dataSource: _generateAverageData(chartData, averageTemperature!),
                                                  xValueMapper: (TemperatureChartData data, int index) => data.year,
                                                  yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                                                  color: kAverageColour,
                                                  width: 2,
                                                  name: 'Average Temperature',
                                                  markerSettings: MarkerSettings(isVisible: false),
                                                ),
                                              if (trendSlope != null)
                                                LineSeries<TemperatureChartData, String>(
                                                  dataSource: _generateTrendData(chartData, trendSlope!),
                                                  xValueMapper: (TemperatureChartData data, int index) => data.year,
                                                  yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                                                  color: kTrendColour,
                                                  width: 2,
                                                  name: 'Trend',
                                                  markerSettings: MarkerSettings(isVisible: false),
                                                ),
                                            ],
                                            primaryXAxis: CategoryAxis(
                                              labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                                              majorGridLines: MajorGridLines(width: 0),
                                              labelIntersectAction: AxisLabelIntersectAction.hide,
                                            ),
                                            primaryYAxis: NumericAxis(
                                              labelFormat: '{value}°C',
                                              numberFormat: NumberFormat('0'),
                                              minimum: yAxisMin,
                                              maximum: yAxisMax,
                                              majorGridLines: MajorGridLines(width: 0),
                                              labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                                            ),
                                            plotAreaBorderWidth: 0,
                                          ),
                                        ),
                                        // Add average and trend info below the chart
                                        if (averageTemperature != null)
                                          Padding(
                                            padding: const EdgeInsets.only(top: kSectionTopPadding),
                                            child: Align(
                                              alignment: Alignment.centerLeft,
                                              child: Container(
                                                margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                                                child: Text(
                                                  'Average: ${averageTemperature.toStringAsFixed(1)}°C',
                                                  style: TextStyle(color: kAverageColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                                  textAlign: TextAlign.left,
                                                ),
                                              ),
                                            ),
                                          ),
                                        if (trendSlope != null)
                                          Padding(
                                            padding: const EdgeInsets.only(top: kSectionTopPadding),
                                            child: Align(
                                              alignment: Alignment.centerLeft,
                                              child: Container(
                                                margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                                                child: Text(
                                                  (trendSlope.abs() < 0.01)
                                                    ? 'Trend: stable'
                                                    : 'Trend: ${trendSlope > 0 ? 'rising' : 'falling'} at ${trendSlope.abs().toStringAsFixed(1)}°C/decade',
                                                  style: TextStyle(color: kTrendColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                                  textAlign: TextAlign.left,
                                                ),
                                              ),
                                            ),
                                          ),
                                      ],
                                    ),
                                  ),
                                );
                              },
                            ),
                          ),
                        );
                      },
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
      ),
    );
  }
}

class TemperatureChartData {
  final String year;
  final double temperature;
  final bool isCurrentYear;

  TemperatureChartData({
    required this.year,
    required this.temperature,
    required this.isCurrentYear,
  });
}

List<TemperatureChartData> _generateTrendData(List<TemperatureChartData> chartData, double slope) {
  if (chartData.isEmpty) return [];
  
  // Find the middle year to use as reference point
  final years = chartData.map((data) => int.parse(data.year)).toList();
  years.sort();
  final middleYear = years[years.length ~/ 2];
  
  // Calculate the middle temperature (average of all temperatures)
  final middleTemp = chartData.map((data) => data.temperature).reduce((a, b) => a + b) / chartData.length;
  
  // Generate trend line points using only the actual years from chart data
  return chartData.map((data) {
    final year = int.parse(data.year);
    final yearsFromMiddle = year - middleYear;
    final trendTemp = middleTemp + (slope * yearsFromMiddle / 10); // Convert decade slope to yearly
    
    return TemperatureChartData(
      year: data.year,
      temperature: trendTemp,
      isCurrentYear: data.isCurrentYear,
    );
  }).toList();
}

List<TemperatureChartData> _generateAverageData(List<TemperatureChartData> chartData, double averageTemp) {
  if (chartData.isEmpty) return [];
  
  // Generate average line points using only the actual years from chart data
  return chartData.map((data) {
    return TemperatureChartData(
      year: data.year,
      temperature: averageTemp,
      isCurrentYear: data.isCurrentYear,
    );
  }).toList();
}

String _formatDayMonth(DateTime date) {
  final day = date.day;
  final month = DateFormat('MMMM').format(date);
  String suffix;
  if (day >= 11 && day <= 13) {
    suffix = 'th';
  } else {
    switch (day % 10) {
      case 1:
        suffix = 'st';
        break;
      case 2:
        suffix = 'nd';
        break;
      case 3:
        suffix = 'rd';
        break;
      default:
        suffix = 'th';
    }
  }
  return '$day$suffix $month';
}

// Sign up
Future<UserCredential> signUp(String email, String password) async {
  return await FirebaseAuth.instance.createUserWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign in
Future<UserCredential> signIn(String email, String password) async {
  return await FirebaseAuth.instance.signInWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign out
Future<void> signOut() async {
  await FirebaseAuth.instance.signOut();
}
