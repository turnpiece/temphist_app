import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:geolocator/geolocator.dart' as geo;
import 'package:geocoding/geocoding.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // This is auto-generated by FlutterFire CLI
import 'package:firebase_auth/firebase_auth.dart';
import 'package:http/http.dart' as http;
import 'package:flutter/services.dart';
import 'dart:io' show Platform;
import 'dart:async';

import 'services/temperature_service.dart';

// App color constants
const bool DEBUGGING = false;
const kBackgroundColour = Color(0xFF242456);
const kAccentColour = Color(0xFFFF6B6B);
const kTextPrimaryColour = Color(0xFFECECEC);
const kSummaryColour = Color(0xFF51CF66);
const kAverageColour = Color(0xFF4DABF7);
const kTrendColour = Color(0xFFAAAA00);
const kTrendLineColour = kTrendColour;
const kBarOtherYearColour = kAccentColour;
const kBarCurrentYearColour = kSummaryColour;
const kAxisLabelColour = Color(0xFFECECEC);
const kAxisGridColour = kAxisLabelColour;
const kGreyLabelColour = Color(0xFFB0B0B0);

// Layout constants for easy adjustment
const double kScreenPadding = 8.0;
const double kTitleRowHorizontalMargin = 4.0;
const double kTitleRowIconRightPadding = 6.0;
const double kSectionHorizontalMargin = 4.0;
const double kCitySummaryHorizontalMargin = 4.0;
const double kChartHorizontalMargin = 4.0;
const double kChartInnerPadding = 4.0;
const double kSectionBottomPadding = 22.0;
const double kSectionTopPadding = 22.0;
const double kContentVerticalPadding = 32.0; // Vertical padding for main content area

// Font size constants
const double kFontSizeTitle = 20.0;
const double kFontSizeBody = 14.0;
const double kFontSizeAxisLabel = 12.0;

// Time constants
const int kUseYesterdayHourThreshold = 3; // Use yesterday's data if current hour is before this

void debugPrintIfDebugging(Object? message) {
  if (DEBUGGING) {
    // ignore: avoid_print
    print('DEBUG: $message');
  }
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Configure system UI overlay to extend app background over status bar and navigation bar
  _setSystemUIOverlayStyle();
  
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  // Ensure user is signed in (anonymous)
  await _ensureSignedIn();
  runApp(MyApp());
}

void _setSystemUIOverlayStyle() {
  if (kIsWeb) {
    // Web-specific configuration - minimal setup since web doesn't have system UI overlays
    // No need to set SystemUIOverlayStyle on web
    return;
  } else if (Platform.isIOS) {
    // iOS-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarBrightness: Brightness.dark, // Light text on dark background
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else if (Platform.isAndroid) {
    // Android-specific configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light, // Light icons/text
        systemNavigationBarColor: Colors.transparent,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );
  } else {
    // For other platforms, use a default configuration
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        systemNavigationBarColor: Colors.transparent,
      ),
    );
  }
}

Future<void> _ensureSignedIn() async {
  final auth = FirebaseAuth.instance;
  if (auth.currentUser == null) {
    await auth.signInAnonymously();
  }
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly
    _setSystemUIOverlayStyle();
    
    return MaterialApp(
      title: 'Temperature Trends',
      home: TemperatureScreen(),
    );
  }
}

class TemperatureScreen extends StatefulWidget {
  final Future<Map<String, dynamic>?>? testFuture;
  final AsyncSnapshot<Map<String, dynamic>?>? testSnapshot;

  TemperatureScreen({this.testFuture, this.testSnapshot});

  @override
  _TemperatureScreenState createState() => _TemperatureScreenState();
}

class _TemperatureScreenState extends State<TemperatureScreen> {
  late Future<Map<String, dynamic>?> futureChartData;
  bool _hasFreshData = false;
  bool _isShowingCachedData = false;
  Timer? _dateCheckTimer;
  DateTime? _lastCheckedDate;

  @override
  void initState() {
    super.initState();
    _loadInitialData();
    _startDateCheckTimer();
  }

  @override
  void dispose() {
    _dateCheckTimer?.cancel();
    super.dispose();
  }

  void _loadInitialData() async {
    debugPrintIfDebugging('_loadInitialData: Starting data load');
    
    // Use test data if provided
    if (widget.testFuture != null) {
      debugPrintIfDebugging('_loadInitialData: Using test data');
      futureChartData = widget.testFuture!;
      return;
    }
    
    // Initialize with loading state immediately
    setState(() {
      futureChartData = _loadChartData();
    });
    
    // First, try to load cached data and show it immediately if available
    debugPrintIfDebugging('_loadInitialData: Checking for cached data');
    final cached = await _loadCachedChartData();
    if (cached != null) {
      // Check if cached data has at least some chart data
      final hasChartData = cached['chartData'] != null && 
                          (cached['chartData'] as List).isNotEmpty;
      
      if (hasChartData) {
        debugPrintIfDebugging('_loadInitialData: Found cached data with chart data, using it');
        setState(() {
          futureChartData = Future.value(cached);
          _isShowingCachedData = true;
        });
        
        // Try to fetch fresh data in the background
        debugPrintIfDebugging('_loadInitialData: Fetching fresh data in background');
        Future.delayed(Duration.zero, () async {
          try {
            final freshFuture = _loadChartData();
            final fresh = await freshFuture;
            if (fresh != null) {
              debugPrintIfDebugging('_loadInitialData: Fresh data received, updating UI');
              setState(() {
                futureChartData = Future.value(fresh);
                _isShowingCachedData = false;
              });
            } else {
              debugPrintIfDebugging('_loadInitialData: Fresh data load returned null (fresh data arrived), keeping cached data');
            }
          } catch (e) {
            debugPrintIfDebugging('Background data refresh failed: $e');
            // If background refresh fails, we should still try to show the cached data
            // but log that it might be incomplete
            debugPrintIfDebugging('Background refresh failed, showing cached data (may be incomplete)');
          }
        });
      } else {
        debugPrintIfDebugging('_loadInitialData: Found cached data but no chart data, loading fresh data');
        // If cached data has no chart data, don't show it and load fresh data instead
        setState(() {
          futureChartData = _loadChartData();
          _isShowingCachedData = false;
        });
      }
    } else {
      debugPrintIfDebugging('_loadInitialData: No cached data found, using fresh load');
      // If no cached data is available, we're already loading fresh data
      // The FutureBuilder will handle the loading state and any errors
    }
  }

  Future<Map<String, dynamic>?> _loadChartData() async {
    debugPrintIfDebugging('_loadChartData: Starting chart data load');
    final now = DateTime.now();
    final useYesterday = now.hour < kUseYesterdayHourThreshold;
    final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
    final formattedDate = DateFormat('yyyy-MM-dd').format(dateToUse);
    debugPrintIfDebugging('_loadChartData: Using date $formattedDate');

    final service = TemperatureService();
    String city = 'London';
    debugPrintIfDebugging('_loadChartData: Starting geolocation check');
    // Try to get user's city via geolocation
    try {
      bool serviceEnabled = await geo.Geolocator.isLocationServiceEnabled();
      debugPrintIfDebugging('_loadChartData: Location service enabled: $serviceEnabled');
      if (serviceEnabled) {
        geo.LocationPermission permission = await geo.Geolocator.checkPermission();
        debugPrintIfDebugging('_loadChartData: Initial permission: $permission');
        if (permission == geo.LocationPermission.denied) {
          permission = await geo.Geolocator.requestPermission();
          debugPrintIfDebugging('_loadChartData: After request, permission: $permission');
        }
        if (permission == geo.LocationPermission.whileInUse || permission == geo.LocationPermission.always) {
          debugPrintIfDebugging('_loadChartData: Getting current position');
          try {
            geo.Position position = await geo.Geolocator.getCurrentPosition(
              desiredAccuracy: geo.LocationAccuracy.low,
            ).timeout(const Duration(seconds: 10));
            debugPrintIfDebugging('_loadChartData: Got position: ${position.latitude}, ${position.longitude}');
            debugPrintIfDebugging('_loadChartData: Getting placemarks');
                        List<Placemark> placemarks = await placemarkFromCoordinates(position.latitude, position.longitude);
            if (placemarks.isNotEmpty && placemarks.first.locality != null && placemarks.first.locality!.isNotEmpty) {
              city = placemarks.first.locality!;
              debugPrintIfDebugging('_loadChartData: Using city: $city');
            } else {
              debugPrintIfDebugging('_loadChartData: No locality found in placemarks');
            }
          } catch (e) {
            debugPrintIfDebugging('_loadChartData: Geolocation timeout or error: $e');
          }
        } else {
          debugPrintIfDebugging('_loadChartData: Location permission denied');
        }
      }
    } catch (e) {
      debugPrintIfDebugging('Geolocation failed, falling back to $city: $e');
    }
    debugPrintIfDebugging('_loadChartData: Final city: $city');
    final currentYear = dateToUse.year;

    List<TemperatureChartData> chartData = [];
    double? averageTemperature;
    double? trendSlope;
    String? summaryText;
    int startYear = currentYear - 50;
    int endYear = currentYear;

    // Helper to fetch year-by-year data
    Future<void> fetchYearlyData(int start, int end) async {
      for (int year = start; year <= end; year++) {
        final dateForYear = '$year-${formattedDate.substring(5)}';
        try {
          final tempData = await service.fetchTemperature(city, dateForYear);
          chartData.add(TemperatureChartData(
            year: year.toString(),
            temperature: tempData.temperature ?? tempData.average?.temperature ?? 0.0,
            isCurrentYear: year == currentYear,
          ));
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch temperature for year $year: $e');
        }
      }
    }

    // Try main /data/ endpoint first
    try {
      debugPrintIfDebugging('_loadChartData: Starting /data/ fetch for $city, $formattedDate');
      final tempData = await service
          .fetchCompleteData(city, '$currentYear-${formattedDate.substring(5)}')
          .timeout(const Duration(seconds: 30));
        debugPrintIfDebugging('_loadChartData: /data/ response: ${tempData.toString()}');
        debugPrintIfDebugging('_loadChartData: tempData.series?.data?.length: ${tempData.series?.data.length}');
        debugPrintIfDebugging('_loadChartData: tempData.summary: ${tempData.summary}');
        debugPrintIfDebugging('_loadChartData: tempData.average?.temperature: ${tempData.average?.temperature}');
        debugPrintIfDebugging('_loadChartData: tempData.trend?.slope: ${tempData.trend?.slope}');
      if (tempData.series?.data.isNotEmpty == true) {
        _hasFreshData = true;
        averageTemperature = tempData.average?.temperature;
        trendSlope = tempData.trend?.slope;
        summaryText = tempData.summary;

        final seriesData = tempData.series!.data;
        for (final dataPoint in seriesData) {
          if (dataPoint.y != null) {
            chartData.add(TemperatureChartData(
              year: dataPoint.x.toString(),
              temperature: (dataPoint.y is num) ? (dataPoint.y as num).toDouble() : 0.0,
              isCurrentYear: dataPoint.x == currentYear,
            ));
          }
        }
        if (tempData.average?.yearRange != null) {
          startYear = tempData.average!.yearRange.start;
          endYear = tempData.average!.yearRange.end;
        }
        final result = _createResultMap(
          chartData: chartData,
          averageTemperature: averageTemperature,
          trendSlope: trendSlope,
          summaryText: summaryText,
          dateToUse: dateToUse,
          city: city,
        );
        return await _cacheAndReturnResult(result);
      } else {
        debugPrintIfDebugging('/data/ returned empty or missing series');
        throw Exception('No series data in /data/ endpoint response');
      }
    } catch (e) {
        debugPrintIfDebugging('Exception in /data/ fetch: $e');
      if (_shouldSkipFallback()) {
        // If fresh data arrived, skip fallback and return null to trigger cache fallback
        return null;
      }
      // Fallback: try /average/, /trend/, /summary/ endpoints
      try {
        debugPrintIfDebugging('Calling /average/ endpoint...');
        final mmdd = (formattedDate.length >= 5) ? formattedDate.substring(5) : '';
        if (mmdd.isEmpty) {
          throw Exception('Invalid date format for /average/ endpoint: $formattedDate');
        }
        final averageData = await service
            .fetchAverageData(city, mmdd)
            .timeout(const Duration(seconds: 30));
        averageTemperature = averageData['average'] != null
            ? (averageData['average'] as num).toDouble()
            : null;
        if (averageTemperature == null) {
          throw Exception('No average temperature available');
        }
        if (averageData['year_range'] != null) {
          final yearRange = averageData['year_range'];
          if (yearRange is Map<String, dynamic>) {
            final start = yearRange['start'];
            final end = yearRange['end'];
            if (start is int && end is int) {
              startYear = start;
              endYear = end;
            }
          }
        }
        // Try to get trend and summary, but don't fail if they are missing
        debugPrintIfDebugging('Calling /trend/ endpoint...');
        try {
          final trendData = await service
              .fetchTrendData(city, mmdd)
              .timeout(const Duration(seconds: 30));
          final slope = trendData['slope'];
          trendSlope = (slope is num) ? slope.toDouble() : null;
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch trend data: $e');
          trendSlope = null;
        }
        debugPrintIfDebugging('Calling /summary/ endpoint...');
        try {
          final summaryData = await service
              .fetchSummaryData(city, mmdd)
              .timeout(const Duration(seconds: 30));
          // Safely extract summary text
          final summaryRaw = summaryData['summary'];
          summaryText = summaryRaw?.toString();
          debugPrintIfDebugging('Summary endpoint response: $summaryData');
          debugPrintIfDebugging('Summary raw value: $summaryRaw');
          debugPrintIfDebugging('Summary text extracted: $summaryText');
        } catch (e) {
          debugPrintIfDebugging('Failed to fetch summary data: $e');
          summaryText = null;
        }
        await fetchYearlyData(startYear, endYear);
        if (_shouldSkipFallback()) {
          // If fresh data arrived, skip fallback and return null to trigger cache fallback
          return null;
        }
        debugPrintIfDebugging('Fallback result: averageTemperature=$averageTemperature, trendSlope=$trendSlope, summaryText=$summaryText');
        final result = _createResultMap(
          chartData: chartData,
          averageTemperature: averageTemperature,
          trendSlope: trendSlope,
          summaryText: summaryText,
          dateToUse: dateToUse,
          city: city,
        );
        return await _cacheAndReturnResult(result);
      } catch (e) {
        debugPrintIfDebugging('Fallback endpoints failed, using year-by-year only: $e');
        // Final fallback: just fetch year-by-year
        await fetchYearlyData(startYear, endYear);
        // No summary, average, or trend available in this fallback
        averageTemperature = null;
        trendSlope = null;
        summaryText = null;
        debugPrintIfDebugging('Final fallback (year-by-year only): averageTemperature=$averageTemperature, trendSlope=$trendSlope, summaryText=$summaryText');
        final result = _createResultMap(
          chartData: chartData,
          averageTemperature: averageTemperature,
          trendSlope: trendSlope,
          summaryText: summaryText,
          dateToUse: dateToUse,
          city: city,
        );
        return await _cacheAndReturnResult(result);
      }
    }
    // If all above fails, try to load from cache (even if date changed)
    final cached = await _loadCachedChartData();
    if (cached != null) {
      debugPrintIfDebugging('Using cached data as fallback after fresh data load failed');
      return cached;
    }
    throw Exception('Unable to load temperature data. Please check your internet connection and try again.');
  }

  Future<void> _cacheChartData(Map<String, dynamic> data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // Validate that chartData exists and is a List
      final chartData = data['chartData'];
      if (chartData == null || chartData is! List<TemperatureChartData>) {
        debugPrintIfDebugging('Invalid chartData for caching, skipping cache');
        return;
      }
      
      // Calculate the date that was used for this data (same logic as _loadChartData)
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold;
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      
      // Only cache the minimal necessary data
      final cache = jsonEncode({
        'chartData': chartData.map((e) => {
          'year': e.year,
          'temperature': e.temperature,
          'isCurrentYear': e.isCurrentYear,
        }).toList(),
        'averageTemperature': data['averageTemperature'],
        'trendSlope': data['trendSlope'],
        'summary': data['summary'],
        'displayDate': data['displayDate'],
        'city': data['city'],
        'cachedDate': DateFormat('yyyy-MM-dd').format(dateToUse), // Store the date that was actually used for the data
      });
      await prefs.setString('cachedChartData', cache);
    } catch (e) {
      debugPrintIfDebugging('Error caching data: $e');
      // Don't throw, just log the error
    }
  }

  Future<Map<String, dynamic>?> _loadCachedChartData() async {
    final prefs = await SharedPreferences.getInstance();
    final cache = prefs.getString('cachedChartData');
    if (cache == null) return null;
    
    try {
      final decoded = jsonDecode(cache);
      
      // Validate that decoded is a Map
      if (decoded == null || decoded is! Map<String, dynamic>) {
        debugPrintIfDebugging('Cached data is not a valid Map, clearing cache');
        await prefs.remove('cachedChartData');
        return null;
      }
      
      // Check if the date has changed since the data was cached
      final cachedDate = decoded['cachedDate'] as String?;
      final now = DateTime.now();
      final useYesterday = now.hour < kUseYesterdayHourThreshold; // Use same logic as _loadChartDataR
      final dateToUse = useYesterday ? now.subtract(Duration(days: 1)) : now;
      final currentDate = DateFormat('yyyy-MM-dd').format(dateToUse);
      
      if (cachedDate != null && cachedDate != currentDate) {
        // Date has changed, but we'll still use cached data as fallback
        // The fresh data load will be attempted first, and if it fails, we'll fall back to cached
        debugPrintIfDebugging('Date changed from $cachedDate to $currentDate, but keeping cached data as fallback');
        // Don't return null here - let the caller decide whether to use cached data
      }
      
      // Safely extract chartData
      final chartDataRaw = decoded['chartData'];
      if (chartDataRaw == null || chartDataRaw is! List) {
        debugPrintIfDebugging('Cached chartData is invalid, clearing cache');
        await prefs.remove('cachedChartData');
        return null;
      }
      
      final chartDataList = chartDataRaw.map((e) {
        // Validate each chart data item
        if (e == null || e is! Map<String, dynamic>) {
          throw Exception('Invalid chart data item in cache');
        }
        
        return TemperatureChartData(
          year: e['year']?.toString() ?? '',
          temperature: (e['temperature'] is num) ? (e['temperature'] as num).toDouble() : 0.0,
          isCurrentYear: e['isCurrentYear'] == true,
        );
      }).toList();
      
      return {
        'chartData': chartDataList,
        'averageTemperature': decoded['averageTemperature'],
        'trendSlope': decoded['trendSlope'],
        'summary': decoded['summary'],
        'displayDate': decoded['displayDate'],
        'city': decoded['city'],
        'cachedDate': cachedDate, // Include the cached date for reference
      };
    } catch (e) {
      debugPrintIfDebugging('Error loading cached data: $e');
      // Clear corrupted cache
      await prefs.remove('cachedChartData');
      return null;
    }
  }

  Future<Map<String, dynamic>> _cacheAndReturnResult(Map<String, dynamic> result) async {
    await _cacheChartData(result);
    return result;
  }

  bool _shouldSkipFallback() {
    if (_hasFreshData) {
      debugPrintIfDebugging('Skipping fallback update because fresh data arrived.');
      return true;
    }
    return false;
  }

  Widget _buildRefreshIndicator(Widget child) {
    return RefreshIndicator(
      onRefresh: () async {
        setState(() {
          futureChartData = _loadChartData();
          _isShowingCachedData = false;
        });
        await futureChartData;
      },
      color: kAccentColour,
      backgroundColor: kBackgroundColour,
      child: child,
    );
  }

  Widget _buildFutureBuilder({required double chartHeight}) {
    return FutureBuilder<Map<String, dynamic>?>(
      future: futureChartData,
      builder: (context, snapshot) {
        final effectiveSnapshot = widget.testSnapshot ?? snapshot;
        if (effectiveSnapshot.connectionState == ConnectionState.waiting) {
          // Don't show loading indicator during pull-to-refresh
          // The RefreshIndicator will show its own indicator
          return const SizedBox.shrink();
        } else if (effectiveSnapshot.hasError) {
          return _buildRetrySection(
            'Error loading data: ${effectiveSnapshot.error}',
            () {
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        } else if (!effectiveSnapshot.hasData || effectiveSnapshot.data == null || effectiveSnapshot.data!.isEmpty) {
          return _buildRetrySection(
            'No temperature data available. Please check your internet connection and try again.',
            () {
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        }

        final data = effectiveSnapshot.data!;
        final chartData = data['chartData'] as List<TemperatureChartData>;
        if (chartData.isEmpty) {
          return _buildRetrySection(
            'No temperature data available. Please check your internet connection and try again.',
            () {
              setState(() {
                futureChartData = _loadChartData();
                _isShowingCachedData = false;
              });
            },
          );
        }
        final averageTemperature = data['averageTemperature'] as double?;
        final trendSlope = data['trendSlope'] as double?;
        final summaryText = data['summary'] as String?;
        final displayDate = data['displayDate'] as String?;
        final city = data['city'] as String?;
        
        debugPrintIfDebugging('Average temperature for plot band: $averageTemperature°C');
        debugPrintIfDebugging('Summary text for UI: $summaryText');
        debugPrintIfDebugging('Summary text is empty: ${summaryText?.isEmpty}');
        debugPrintIfDebugging('Summary text is null: ${summaryText == null}');

        return _buildChartContent(
          chartData: chartData,
          averageTemperature: averageTemperature,
          trendSlope: trendSlope,
          summaryText: summaryText,
          displayDate: displayDate,
          city: city,
          chartHeight: chartHeight,
          isCachedData: _isShowingCachedData,
          cachedDate: data['cachedDate'] as String?,
        );
      },
    );
  }

  void _startDateCheckTimer() {
    _dateCheckTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkDateChange();
    });
  }

  void _checkDateChange() {
    final now = DateTime.now();
    final useYesterday = now.hour < kUseYesterdayHourThreshold;
    final currentDate = useYesterday ? now.subtract(Duration(days: 1)) : now;
    
    if (_lastCheckedDate == null) {
      _lastCheckedDate = currentDate;
      return;
    }
    
    // Check if the date has changed (ignoring time)
    if (_lastCheckedDate!.year != currentDate.year ||
        _lastCheckedDate!.month != currentDate.month ||
        _lastCheckedDate!.day != currentDate.day) {
      debugPrintIfDebugging('Date changed from ${_lastCheckedDate} to $currentDate, reloading data');
      setState(() {
        futureChartData = _loadChartData();
        _isShowingCachedData = false;
      });
    }
    
    _lastCheckedDate = currentDate;
  }

  @override
  Widget build(BuildContext context) {
    // Ensure system UI overlay is set correctly for this screen
    _setSystemUIOverlayStyle();
    
    final double chartHeight = 800;

    Widget appContent = Scaffold(
      body: Stack(
        children: [
          // Gradient background fills the whole screen including system areas
          _buildGradientBackground(),
          // Foreground content scrolls above the background
          _buildRefreshIndicator(
            SingleChildScrollView(
              physics: const AlwaysScrollableScrollPhysics(),
              child: _buildContentPadding(
                context,
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // --- Title/logo row: always visible and scrolls with content ---
                    _buildTitleLogoSection(),
                    // --- The rest of the UI, including the FutureBuilder ---
                    _buildFutureBuilder(chartHeight: chartHeight),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );

    // Only wrap with AnnotatedRegion on mobile platforms
    if (kIsWeb) {
      return appContent;
    } else {
      return AnnotatedRegion<SystemUiOverlayStyle>(
        value: Platform.isIOS
          ? const SystemUiOverlayStyle(
              statusBarColor: Colors.transparent,
              statusBarBrightness: Brightness.dark,
              systemNavigationBarColor: Colors.transparent,
              systemNavigationBarIconBrightness: Brightness.light,
            )
          : const SystemUiOverlayStyle(
              statusBarColor: Colors.transparent,
              statusBarIconBrightness: Brightness.light,
              systemNavigationBarColor: Colors.transparent,
              systemNavigationBarIconBrightness: Brightness.light,
            ),
        child: appContent,
      );
    }
  }
}

class TemperatureChartData {
  final String year;
  final double temperature;
  final bool isCurrentYear;

  TemperatureChartData({
    required this.year,
    required this.temperature,
    required this.isCurrentYear,
  });
}

List<TemperatureChartData> _generateTrendData(List<TemperatureChartData> chartData, double slope) {
  if (chartData.isEmpty) return [];
  
  // Find the middle year to use as reference point
  final years = chartData.map((data) => int.parse(data.year)).toList();
  years.sort();
  final middleYear = years[years.length ~/ 2];
  
  // Calculate the middle temperature (average of all temperatures)
  final middleTemp = chartData.map((data) => data.temperature).reduce((a, b) => a + b) / chartData.length;
  
  // Generate trend line points using only the actual years from chart data
  return chartData.map((data) {
    final year = int.parse(data.year);
    final yearsFromMiddle = year - middleYear;
    final trendTemp = middleTemp + (slope * yearsFromMiddle / 10); // Convert decade slope to yearly
    
    return TemperatureChartData(
      year: data.year,
      temperature: trendTemp,
      isCurrentYear: data.isCurrentYear,
    );
  }).toList();
}

List<TemperatureChartData> _generateAverageData(List<TemperatureChartData> chartData, double averageTemp) {
  if (chartData.isEmpty) return [];
  
  // Generate average line points using only the actual years from chart data
  return chartData.map((data) {
    return TemperatureChartData(
      year: data.year,
      temperature: averageTemp,
      isCurrentYear: data.isCurrentYear,
    );
  }).toList();
}

String _formatDayMonth(DateTime date) {
  final day = date.day;
  final month = DateFormat('MMMM').format(date);
  String suffix;
  if (day >= 11 && day <= 13) {
    suffix = 'th';
  } else {
    switch (day % 10) {
      case 1:
        suffix = 'st';
        break;
      case 2:
        suffix = 'nd';
        break;
      case 3:
        suffix = 'rd';
        break;
      default:
        suffix = 'th';
    }
  }
  return '$day$suffix $month';
}

Map<String, dynamic> _createResultMap({
  required List<TemperatureChartData> chartData,
  required double? averageTemperature,
  required double? trendSlope,
  required String? summaryText,
  required DateTime dateToUse,
  required String city,
}) {
  return {
    'chartData': chartData,
    'averageTemperature': averageTemperature,
    'trendSlope': trendSlope,
    'summary': summaryText,
    'displayDate': _formatDayMonth(dateToUse),
    'city': city,
  };
}

  Widget _buildRetryButton(VoidCallback onPressed) {
    return ElevatedButton(
      onPressed: onPressed,
      child: const Text(
        'Retry',
        style: TextStyle(color: kTextPrimaryColour),
      ),
      style: ElevatedButton.styleFrom(
        backgroundColor: kAccentColour,
      ),
    );
  }

  Widget _buildRetrySection(String message, VoidCallback onRetry) {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        return Center(
          child: Container(
            width: contentWidth,
            margin: EdgeInsets.symmetric(horizontal: horizontalOffset > 0 ? horizontalOffset : kScreenPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  message,
                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody),
                  textAlign: TextAlign.left,
                ),
                const SizedBox(height: 16),
                _buildRetryButton(onRetry),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildGradientBackground() {
    return SizedBox.expand(
      child: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              Color(0xFF242456), // Top color
              Color(0xFF343499), // Bottom color
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTitleLogoSection() {
    return LayoutBuilder(
      builder: (context, constraints) {
        double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
        double horizontalOffset = (constraints.maxWidth - contentWidth) / 2;
        
        debugPrintIfDebugging('Title area - Screen width: ${constraints.maxWidth}, contentWidth: $contentWidth, horizontalOffset: $horizontalOffset, isWideScreen: ${constraints.maxWidth >= 600}');
        
        return Padding(
          padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
          child: Stack(
            children: [
              // Logo positioned to the left of content area
              if (horizontalOffset > 0)
                Positioned(
                  left: horizontalOffset - 60, // Position logo 60px to the left of content (50px + 10px for bar alignment)
                  child: SvgPicture.asset(
                    'assets/logo.svg',
                    width: 40,
                    height: 40,
                  ),
                ),
              // Title text aligned with content left edge
              Align(
                alignment: Alignment.centerLeft,
                child: Container(
                  margin: EdgeInsets.only(
                    left: horizontalOffset > 0 ? horizontalOffset : kTitleRowHorizontalMargin,
                  ),
                  child: Row(
                    children: [
                      // Only show logo inline on narrow screens
                      if (horizontalOffset <= 0)
                        Padding(
                          padding: const EdgeInsets.only(right: kTitleRowIconRightPadding),
                          child: SvgPicture.asset(
                            'assets/logo.svg',
                            width: 40,
                            height: 40,
                          ),
                        ),
                      Text(
                        'TempHist',
                        style: TextStyle(
                          color: kAccentColour,
                          fontSize: kFontSizeTitle,
                          fontWeight: FontWeight.bold,
                          letterSpacing: 1.2,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildContentPadding(BuildContext context, Widget child) {
    return Padding(
      padding: EdgeInsets.only(
        top: MediaQuery.of(context).padding.top + kContentVerticalPadding,
        bottom: MediaQuery.of(context).padding.bottom + kContentVerticalPadding,
        left: kScreenPadding,
        right: kScreenPadding,
      ),
      child: child,
    );
  }

  Widget _buildChartContent({
    required List<TemperatureChartData> chartData,
    required double? averageTemperature,
    required double? trendSlope,
    required String? summaryText,
    required String? displayDate,
    required String? city,
    required double chartHeight,
    bool isCachedData = false,
    String? cachedDate,
  }) {
    // Calculate minimum and maximum temperature for Y-axis
    final minTemp = chartData.map((data) => data.temperature).reduce((a, b) => a < b ? a : b);
    final maxTemp = chartData.map((data) => data.temperature).reduce((a, b) => a > b ? a : b);
    final yAxisMin = (minTemp - 2).floorToDouble(); // Start 2 degrees below minimum
    final yAxisMax = (maxTemp + 2).ceilToDouble(); // End 2 degrees above maximum
    
    debugPrintIfDebugging('_buildChartContent: summaryText = "$summaryText"');
    debugPrintIfDebugging('_buildChartContent: summaryText?.isNotEmpty = ${summaryText?.isNotEmpty}');
    debugPrintIfDebugging('_buildChartContent: kSummaryColour = $kSummaryColour');
    
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(kChartInnerPadding),
        child: LayoutBuilder(
          builder: (context, constraints) {
            double contentWidth = constraints.maxWidth < 600 ? constraints.maxWidth : 600;
            debugPrintIfDebugging('Main content - Screen width: ${constraints.maxWidth}, contentWidth: $contentWidth, isWideScreen: ${constraints.maxWidth >= 600}');
            return Center(
              child: Container(
                width: contentWidth,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Date and location above summary
                    if (displayDate != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kSectionHorizontalMargin),
                            child: Text(
                              isCachedData && cachedDate != null 
                                ? _formatDayMonth(DateFormat('yyyy-MM-dd').parse(cachedDate))
                                : displayDate,
                              style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    if (city != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Row(
                              children: [
                                Text(
                                  city,
                                  style: const TextStyle(color: kTextPrimaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                                  textAlign: TextAlign.left,
                                ),
                                if (isCachedData)
                                  Padding(
                                    padding: const EdgeInsets.only(left: 8.0),
                                    child: Text(
                                      '(cached)',
                                      style: TextStyle(color: kGreyLabelColour, fontSize: kFontSizeBody - 2, fontWeight: FontWeight.w400),
                                      textAlign: TextAlign.left,
                                    ),
                                  ),
                              ],
                            ),
                          ),
                        ),
                      ),
                    if (summaryText?.isNotEmpty == true)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              summaryText!,
                              style: TextStyle(color: kSummaryColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    SizedBox(
                      height: chartHeight,
                      child: SfCartesianChart(
                        margin: EdgeInsets.symmetric(horizontal: kChartHorizontalMargin),
                        tooltipBehavior: TooltipBehavior(
                          enable: true,
                          format: 'point.x: point.y',
                          canShowMarker: false,
                          header: '',
                          textStyle: TextStyle(fontSize: kFontSizeBody),
                        ),
                        series: [
                          BarSeries<TemperatureChartData, String>(
                            dataSource: chartData,
                            xValueMapper: (TemperatureChartData data, int index) => data.year,
                            yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                            pointColorMapper: (TemperatureChartData data, int index) =>
                                data.isCurrentYear ? kBarCurrentYearColour : kBarOtherYearColour,
                            width: 0.8,
                            name: 'Yearly Temperature',
                            enableTooltip: true,
                          ),
                          if (averageTemperature != null)
                            LineSeries<TemperatureChartData, String>(
                              dataSource: _generateAverageData(chartData, averageTemperature!),
                              xValueMapper: (TemperatureChartData data, int index) => data.year,
                              yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                              color: kAverageColour,
                              width: 2,
                              name: 'Average Temperature',
                              markerSettings: MarkerSettings(isVisible: false),
                            ),
                          if (trendSlope != null)
                            LineSeries<TemperatureChartData, String>(
                              dataSource: _generateTrendData(chartData, trendSlope!),
                              xValueMapper: (TemperatureChartData data, int index) => data.year,
                              yValueMapper: (TemperatureChartData data, int index) => data.temperature,
                              color: kTrendColour,
                              width: 2,
                              name: 'Trend',
                              markerSettings: MarkerSettings(isVisible: false),
                            ),
                        ],
                        primaryXAxis: CategoryAxis(
                          labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                          majorGridLines: MajorGridLines(width: 0),
                          labelIntersectAction: AxisLabelIntersectAction.hide,
                        ),
                        primaryYAxis: NumericAxis(
                          labelFormat: '{value}°C',
                          numberFormat: NumberFormat('0'),
                          minimum: yAxisMin,
                          maximum: yAxisMax,
                          majorGridLines: MajorGridLines(width: 0),
                          labelStyle: TextStyle(fontSize: kFontSizeAxisLabel, color: kGreyLabelColour),
                        ),
                        plotAreaBorderWidth: 0,
                      ),
                    ),
                    // Average temperature text below chart
                    if (averageTemperature != null)
                      Padding(
                        padding: const EdgeInsets.only(top: kSectionTopPadding, bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              'Average: ${averageTemperature.toStringAsFixed(1)}°C',
                              style: TextStyle(color: kAverageColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                    // Trend text below chart
                    if (trendSlope != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: kSectionBottomPadding),
                        child: Align(
                          alignment: Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(horizontal: kCitySummaryHorizontalMargin),
                            child: Text(
                              trendSlope > 0 
                                ? 'Trend: Rising at ${trendSlope.abs().toStringAsFixed(1)}°C/decade'
                                : 'Trend: Falling at ${trendSlope.abs().toStringAsFixed(1)}°C/decade',
                              style: TextStyle(color: kTrendColour, fontSize: kFontSizeBody, fontWeight: FontWeight.w400),
                              textAlign: TextAlign.left,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

    // Sign up
Future<UserCredential> signUp(String email, String password) async {
  return await FirebaseAuth.instance.createUserWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign in
Future<UserCredential> signIn(String email, String password) async {
  return await FirebaseAuth.instance.signInWithEmailAndPassword(
    email: email,
    password: password,
  );
}

// Sign out
Future<void> signOut() async {
  await FirebaseAuth.instance.signOut();
}
